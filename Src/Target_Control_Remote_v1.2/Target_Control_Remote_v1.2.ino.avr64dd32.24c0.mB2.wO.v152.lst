
C:\Users\peake\AppData\Local\Temp\arduino_build_540981/Target_Control_Remote_v1.2.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	54 c0       	rjmp	.+168    	; 0xaa <__ctors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	85 c0       	rjmp	.+266    	; 0x110 <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	83 c0       	rjmp	.+262    	; 0x110 <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	81 c0       	rjmp	.+258    	; 0x110 <__bad_interrupt>
       e:	00 00       	nop
../../../../crt1/gcrt1.S:70
      10:	7f c0       	rjmp	.+254    	; 0x110 <__bad_interrupt>
      12:	00 00       	nop
../../../../crt1/gcrt1.S:71
      14:	7d c0       	rjmp	.+250    	; 0x110 <__bad_interrupt>
      16:	00 00       	nop
../../../../crt1/gcrt1.S:72
      18:	7b c0       	rjmp	.+246    	; 0x110 <__bad_interrupt>
      1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
      1c:	79 c0       	rjmp	.+242    	; 0x110 <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	4f c7       	rjmp	.+3742   	; 0xec0 <__vector_8>
      22:	00 00       	nop
../../../../crt1/gcrt1.S:75
      24:	75 c0       	rjmp	.+234    	; 0x110 <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	73 c0       	rjmp	.+230    	; 0x110 <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	71 c0       	rjmp	.+226    	; 0x110 <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	6f c0       	rjmp	.+222    	; 0x110 <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	6d c0       	rjmp	.+218    	; 0x110 <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	6b c0       	rjmp	.+214    	; 0x110 <__bad_interrupt>
      3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
      3c:	69 c0       	rjmp	.+210    	; 0x110 <__bad_interrupt>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	67 c0       	rjmp	.+206    	; 0x110 <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	65 c0       	rjmp	.+202    	; 0x110 <__bad_interrupt>
      46:	00 00       	nop
../../../../crt1/gcrt1.S:84
      48:	63 c0       	rjmp	.+198    	; 0x110 <__bad_interrupt>
      4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
      4c:	61 c0       	rjmp	.+194    	; 0x110 <__bad_interrupt>
      4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
      50:	5f c0       	rjmp	.+190    	; 0x110 <__bad_interrupt>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	91 c6       	rjmp	.+3362   	; 0xd78 <__vector_21>
      56:	00 00       	nop
../../../../crt1/gcrt1.S:88
      58:	89 c6       	rjmp	.+3346   	; 0xd6c <__vector_22>
      5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
      5c:	93 c6       	rjmp	.+3366   	; 0xd84 <__vector_23>
      5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
      60:	2c c7       	rjmp	.+3672   	; 0xeba <__vector_24>
      62:	00 00       	nop
../../../../crt1/gcrt1.S:91
      64:	55 c0       	rjmp	.+170    	; 0x110 <__bad_interrupt>
      66:	00 00       	nop
../../../../crt1/gcrt1.S:92
      68:	53 c0       	rjmp	.+166    	; 0x110 <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	51 c0       	rjmp	.+162    	; 0x110 <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	4f c0       	rjmp	.+158    	; 0x110 <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	4d c0       	rjmp	.+154    	; 0x110 <__bad_interrupt>
      76:	00 00       	nop
../../../../crt1/gcrt1.S:96
      78:	01 c7       	rjmp	.+3586   	; 0xe7c <__vector_30>
      7a:	00 00       	nop
../../../../crt1/gcrt1.S:97
      7c:	49 c0       	rjmp	.+146    	; 0x110 <__bad_interrupt>
      7e:	00 00       	nop
../../../../crt1/gcrt1.S:98
      80:	47 c0       	rjmp	.+142    	; 0x110 <__bad_interrupt>
      82:	00 00       	nop
../../../../crt1/gcrt1.S:99
      84:	45 c0       	rjmp	.+138    	; 0x110 <__bad_interrupt>
      86:	00 00       	nop
../../../../crt1/gcrt1.S:100
      88:	15 c7       	rjmp	.+3626   	; 0xeb4 <__vector_34>
      8a:	00 00       	nop
../../../../crt1/gcrt1.S:101
      8c:	41 c0       	rjmp	.+130    	; 0x110 <__bad_interrupt>
	...

00000090 <__trampolines_end>:
__trampolines_start():
      90:	00 01       	movw	r0, r0
      92:	02 03       	mulsu	r16, r18
      94:	04 05       	cpc	r16, r4

00000096 <_usart0_pins>:
      96:	00 00 02 01 04 06 02 02 ff 03 10 12 04 09 0b 05     ................
      a6:	00 07                                               ..

000000a8 <__ctors_start>:
__ctors_start():
      a8:	ae 07       	cpc	r26, r30

000000aa <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
      aa:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
      ac:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
      ae:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
      b0:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
      b2:	df e7       	ldi	r29, 0x7F	; 127
../../../../crt1/gcrt1.S:237
      b4:	de bf       	out	0x3e, r29	; 62

000000b6 <_initThreeStuff()>:
_Z15_initThreeStuffv():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/main.cpp:103

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
      b6:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x7f0040>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/main.cpp:104
    RSTCTRL.RSTFR = flags;
      ba:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7f0040>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/main.cpp:105
    if (flags == 0) {
      be:	81 11       	cpse	r24, r1
      c0:	05 c0       	rjmp	.+10     	; 0xcc <_initThreeStuff()+0x16>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/main.cpp:106
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
      c2:	98 ed       	ldi	r25, 0xD8	; 216
      c4:	21 e0       	ldi	r18, 0x01	; 1
      c6:	94 bf       	out	0x34, r25	; 52
      c8:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <__TEXT_REGION_LENGTH__+0x7f0041>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/main.cpp:108
    }
    GPIOR0 = flags;
      cc:	8c bb       	out	0x1c, r24	; 28

000000ce <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
      ce:	21 e6       	ldi	r18, 0x61	; 97
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
      d0:	a0 eb       	ldi	r26, 0xB0	; 176
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
      d2:	b0 e6       	ldi	r27, 0x60	; 96
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
      d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
      d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
      d8:	ab 3b       	cpi	r26, 0xBB	; 187
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
      da:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
      dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>

000000de <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
      de:	10 e6       	ldi	r17, 0x60	; 96
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
      e0:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
      e2:	b0 e6       	ldi	r27, 0x60	; 96
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
      e4:	e2 e1       	ldi	r30, 0x12	; 18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
      e6:	f6 e1       	ldi	r31, 0x16	; 22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
      e8:	02 c0       	rjmp	.+4      	; 0xee <__do_copy_data+0x10>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
      ea:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
      ec:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
      ee:	a0 3b       	cpi	r26, 0xB0	; 176
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
      f0:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
      f2:	d9 f7       	brne	.-10     	; 0xea <__do_copy_data+0xc>

000000f4 <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
      f4:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
      f6:	c5 e5       	ldi	r28, 0x55	; 85
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
      f8:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
      fa:	04 c0       	rjmp	.+8      	; 0x104 <__EEPROM_REGION_LENGTH__+0x4>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
      fc:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
      fe:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     100:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     104:	c4 35       	cpi	r28, 0x54	; 84
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     106:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     108:	c9 f7       	brne	.-14     	; 0xfc <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     10a:	bd d7       	rcall	.+3962   	; 0x1086 <main>
../../../../crt1/gcrt1.S:315
     10c:	0c 94 07 0b 	jmp	0x160e	; 0x160e <_exit>

00000110 <__bad_interrupt>:
__vector_28():
../../../../crt1/gcrt1.S:209
     110:	77 cf       	rjmp	.-274    	; 0x0 <__vectors>

00000112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>:
_ZN8SPIClass8transferEh.constprop.48():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:600
  * The following NOP introduces a small delay that can prevent the wait
  * loop from iterating when running at the maximum speed. This gives
  * about 10% more speed, even if it seems counter-intuitive. At lower
  * speeds it is unnoticed.
  */
  asm volatile("nop");
     112:	00 00       	nop
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:602

  SPI_MODULE.DATA = data;
     114:	80 93 44 09 	sts	0x0944, r24	; 0x800944 <__TEXT_REGION_LENGTH__+0x7f0944>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:603
  while ((SPI_MODULE.INTFLAGS & SPI_RXCIF_bm) == 0);  // wait for complete send
     118:	80 91 43 09 	lds	r24, 0x0943	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
     11c:	87 ff       	sbrs	r24, 7
     11e:	fc cf       	rjmp	.-8      	; 0x118 <SPIClass::transfer(unsigned char) [clone .constprop.48]+0x6>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:604
  return SPI_MODULE.DATA;                             // read data back
     120:	80 91 44 09 	lds	r24, 0x0944	; 0x800944 <__TEXT_REGION_LENGTH__+0x7f0944>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:605
}
     124:	08 95       	ret

00000126 <attachInterrupt.part.0.constprop.21>:
attachInterrupt.part.0.constprop.21():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:111
   * of which there are only 7 ports worth of registers available. So this implementation is guaranteed not to work on a
   * future part with 8 ports anyway. We will cross that bridge once Microchip has announced intent to build it.
   */

  void  attachInterrupt(uint8_t pin, void (*userFunc)(void), uint8_t mode) {
    uint8_t bitpos = digitalPinToBitPosition(pin);
     126:	28 2f       	mov	r18, r24
     128:	30 e0       	ldi	r19, 0x00	; 0
     12a:	f9 01       	movw	r30, r18
     12c:	e7 58       	subi	r30, 0x87	; 135
     12e:	ff 49       	sbci	r31, 0x9F	; 159
     130:	90 81       	ld	r25, Z
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:112
    if (bitpos == NOT_A_PIN) {
     132:	9f 3f       	cpi	r25, 0xFF	; 255
     134:	61 f1       	breq	.+88     	; 0x18e <attachInterrupt.part.0.constprop.21+0x68>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:115
      return;
    }
    uint8_t port = digitalPinToPort(pin);
     136:	23 5a       	subi	r18, 0xA3	; 163
     138:	3f 49       	sbci	r19, 0x9F	; 159
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:132
        mode = PORT_ISC_LEVEL_gc;
        break;
      default:
        return;
    }
    if (intFunc[port] != NULL && userFunc != NULL) {
     13a:	d9 01       	movw	r26, r18
     13c:	ec 91       	ld	r30, X
     13e:	f0 e0       	ldi	r31, 0x00	; 0
     140:	df 01       	movw	r26, r30
     142:	aa 0f       	add	r26, r26
     144:	bb 1f       	adc	r27, r27
     146:	a9 5f       	subi	r26, 0xF9	; 249
     148:	bf 49       	sbci	r27, 0x9F	; 159
     14a:	2d 91       	ld	r18, X+
     14c:	3c 91       	ld	r19, X
     14e:	21 15       	cp	r18, r1
     150:	31 05       	cpc	r19, r1
     152:	e9 f0       	breq	.+58     	; 0x18e <attachInterrupt.part.0.constprop.21+0x68>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:134
      // if it is null the port is not enabled for attachInterrupt, and obviously a null user function is invalid too.
      intFunc[port][bitpos] = userFunc;
     154:	49 2f       	mov	r20, r25
     156:	50 e0       	ldi	r21, 0x00	; 0
     158:	44 0f       	add	r20, r20
     15a:	55 1f       	adc	r21, r21
     15c:	24 0f       	add	r18, r20
     15e:	35 1f       	adc	r19, r21
     160:	48 e0       	ldi	r20, 0x08	; 8
     162:	56 e0       	ldi	r21, 0x06	; 6
     164:	d9 01       	movw	r26, r18
     166:	4d 93       	st	X+, r20
     168:	5c 93       	st	X, r21
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:136
      uint8_t portoffset = ((port << 5) & 0xE0) + 0x10 + bitpos;
      uint8_t oldSREG = SREG;
     16a:	4f b7       	in	r20, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:137
      cli();
     16c:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:135
        return;
    }
    if (intFunc[port] != NULL && userFunc != NULL) {
      // if it is null the port is not enabled for attachInterrupt, and obviously a null user function is invalid too.
      intFunc[port][bitpos] = userFunc;
      uint8_t portoffset = ((port << 5) & 0xE0) + 0x10 + bitpos;
     16e:	9f 01       	movw	r18, r30
     170:	55 e0       	ldi	r21, 0x05	; 5
     172:	22 0f       	add	r18, r18
     174:	33 1f       	adc	r19, r19
     176:	5a 95       	dec	r21
     178:	e1 f7       	brne	.-8      	; 0x172 <attachInterrupt.part.0.constprop.21+0x4c>
     17a:	e0 e1       	ldi	r30, 0x10	; 16
     17c:	e9 0f       	add	r30, r25
     17e:	e2 0f       	add	r30, r18
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:139
      uint8_t oldSREG = SREG;
      cli();
      // We now have the port, the mode, the bitpos and the pointer
      uint8_t settings = *(portbase + portoffset) & 0xF8;
     180:	f0 e0       	ldi	r31, 0x00	; 0
     182:	fc 5f       	subi	r31, 0xFC	; 252
     184:	80 81       	ld	r24, Z
     186:	88 7f       	andi	r24, 0xF8	; 248
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:140
      *(portbase + portoffset) = settings | mode;
     188:	83 60       	ori	r24, 0x03	; 3
     18a:	80 83       	st	Z, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:141
      SREG = oldSREG;
     18c:	4f bf       	out	0x3f, r20	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:144
    }

  }
     18e:	08 95       	ret

00000190 <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     190:	af 92       	push	r10
     192:	bf 92       	push	r11
     194:	cf 92       	push	r12
     196:	df 92       	push	r13
     198:	ef 92       	push	r14
     19a:	ff 92       	push	r15
     19c:	0f 93       	push	r16
     19e:	1f 93       	push	r17
     1a0:	cf 93       	push	r28
     1a2:	df 93       	push	r29
     1a4:	6c 01       	movw	r12, r24
     1a6:	7b 01       	movw	r14, r22
     1a8:	8b 01       	movw	r16, r22
     1aa:	04 0f       	add	r16, r20
     1ac:	15 1f       	adc	r17, r21
     1ae:	eb 01       	movw	r28, r22
     1b0:	5e 01       	movw	r10, r28
     1b2:	ae 18       	sub	r10, r14
     1b4:	bf 08       	sbc	r11, r15
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     1b6:	c0 17       	cp	r28, r16
     1b8:	d1 07       	cpc	r29, r17
     1ba:	59 f0       	breq	.+22     	; 0x1d2 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:32
    if (write(*buffer++)) {
     1bc:	69 91       	ld	r22, Y+
     1be:	d6 01       	movw	r26, r12
     1c0:	ed 91       	ld	r30, X+
     1c2:	fc 91       	ld	r31, X
     1c4:	01 90       	ld	r0, Z+
     1c6:	f0 81       	ld	r31, Z
     1c8:	e0 2d       	mov	r30, r0
     1ca:	c6 01       	movw	r24, r12
     1cc:	09 95       	icall
     1ce:	89 2b       	or	r24, r25
     1d0:	79 f7       	brne	.-34     	; 0x1b0 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     1d2:	c5 01       	movw	r24, r10
     1d4:	df 91       	pop	r29
     1d6:	cf 91       	pop	r28
     1d8:	1f 91       	pop	r17
     1da:	0f 91       	pop	r16
     1dc:	ff 90       	pop	r15
     1de:	ef 90       	pop	r14
     1e0:	df 90       	pop	r13
     1e2:	cf 90       	pop	r12
     1e4:	bf 90       	pop	r11
     1e6:	af 90       	pop	r10
     1e8:	08 95       	ret

000001ea <HardwareSerial::availableForWrite()>:
_ZN14HardwareSerial17availableForWriteEv():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:727
      int HardwareSerial::availableForWrite(void) {
        tx_buffer_index_t head;
        tx_buffer_index_t tail;

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
     1ea:	fc 01       	movw	r30, r24
     1ec:	51 89       	ldd	r21, Z+17	; 0x11
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:728
          tail = _tx_buffer_tail;
     1ee:	42 89       	ldd	r20, Z+18	; 0x12
     1f0:	25 2f       	mov	r18, r21
     1f2:	30 e0       	ldi	r19, 0x00	; 0
     1f4:	84 2f       	mov	r24, r20
     1f6:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:731
        }
        if (head >= tail) {
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     1f8:	82 1b       	sub	r24, r18
     1fa:	93 0b       	sbc	r25, r19
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:730

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
          tail = _tx_buffer_tail;
        }
        if (head >= tail) {
     1fc:	54 17       	cp	r21, r20
     1fe:	10 f0       	brcs	.+4      	; 0x204 <HardwareSerial::availableForWrite()+0x1a>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:731
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     200:	cf 96       	adiw	r24, 0x3f	; 63
     202:	08 95       	ret
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:733
        }
        return tail - head - 1;
     204:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:734
      }
     206:	08 95       	ret

00000208 <HardwareSerial::read()>:
_ZN14HardwareSerial4readEv():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:711
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }

    int HardwareSerial::read(void) {
     208:	fc 01       	movw	r30, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:713
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
     20a:	97 85       	ldd	r25, Z+15	; 0x0f
     20c:	80 89       	ldd	r24, Z+16	; 0x10
     20e:	98 17       	cp	r25, r24
     210:	61 f0       	breq	.+24     	; 0x22a <HardwareSerial::read()+0x22>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:716
        return -1;
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
     212:	a0 89       	ldd	r26, Z+16	; 0x10
     214:	ae 0f       	add	r26, r30
     216:	bf 2f       	mov	r27, r31
     218:	b1 1d       	adc	r27, r1
     21a:	53 96       	adiw	r26, 0x13	; 19
     21c:	8c 91       	ld	r24, X
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:717
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
     21e:	90 89       	ldd	r25, Z+16	; 0x10
     220:	9f 5f       	subi	r25, 0xFF	; 255
     222:	9f 73       	andi	r25, 0x3F	; 63
     224:	90 8b       	std	Z+16, r25	; 0x10
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:718
        return c;
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	08 95       	ret
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:714
    }

    int HardwareSerial::read(void) {
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     22a:	8f ef       	ldi	r24, 0xFF	; 255
     22c:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:720
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
        return c;
      }
    }
     22e:	08 95       	ret

00000230 <HardwareSerial::peek()>:
_ZN14HardwareSerial4peekEv():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:703

    int HardwareSerial::available(void) {
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
     230:	fc 01       	movw	r30, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:704
      if (_rx_buffer_head == _rx_buffer_tail) {
     232:	97 85       	ldd	r25, Z+15	; 0x0f
     234:	80 89       	ldd	r24, Z+16	; 0x10
     236:	98 17       	cp	r25, r24
     238:	31 f0       	breq	.+12     	; 0x246 <HardwareSerial::peek()+0x16>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:707
        return -1;
      } else {
        return _rx_buffer[_rx_buffer_tail];
     23a:	80 89       	ldd	r24, Z+16	; 0x10
     23c:	e8 0f       	add	r30, r24
     23e:	f1 1d       	adc	r31, r1
     240:	83 89       	ldd	r24, Z+19	; 0x13
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	08 95       	ret
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:705
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     246:	8f ef       	ldi	r24, 0xFF	; 255
     248:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:709
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }
     24a:	08 95       	ret

0000024c <HardwareSerial::available()>:
_ZN14HardwareSerial9availableEv():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:699
      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    }

    int HardwareSerial::available(void) {
     24c:	fc 01       	movw	r30, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:700
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
     24e:	97 85       	ldd	r25, Z+15	; 0x0f
     250:	20 89       	ldd	r18, Z+16	; 0x10
     252:	89 2f       	mov	r24, r25
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	80 5c       	subi	r24, 0xC0	; 192
     258:	9f 4f       	sbci	r25, 0xFF	; 255
     25a:	82 1b       	sub	r24, r18
     25c:	91 09       	sbc	r25, r1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:701
    }
     25e:	8f 73       	andi	r24, 0x3F	; 63
     260:	99 27       	eor	r25, r25
     262:	08 95       	ret

00000264 <HardwareSerial::_poll_tx_data_empty()>:
_ZN14HardwareSerial19_poll_tx_data_emptyEv():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:426
        HardwareSerial._tx_buffer_tail = txTail;
      }
    #endif

    // To invoke data empty "interrupt" via a call, use this method
    void HardwareSerial::_poll_tx_data_empty(void) {
     264:	fc 01       	movw	r30, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:427
      if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
     266:	0f b6       	in	r0, 0x3f	; 63
     268:	07 fe       	sbrs	r0, 7
     26a:	04 c0       	rjmp	.+8      	; 0x274 <HardwareSerial::_poll_tx_data_empty()+0x10>
     26c:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x7f0111>
     270:	88 23       	and	r24, r24
     272:	a1 f0       	breq	.+40     	; 0x29c <_poll_dre_done>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:444
        // so we'll have to poll the "data register empty" flag ourselves.
        // If it is set, pretend an interrupt has happened and call the handler
        // to free up space for us.
        // -Spence 10/23/20
        // Invoke interrupt handler only if conditions data register is empty
        if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     274:	a0 85       	ldd	r26, Z+8	; 0x08
     276:	b1 85       	ldd	r27, Z+9	; 0x09
     278:	14 96       	adiw	r26, 0x04	; 4
     27a:	8c 91       	ld	r24, X
     27c:	14 97       	sbiw	r26, 0x04	; 4
     27e:	85 ff       	sbrs	r24, 5
     280:	0d c0       	rjmp	.+26     	; 0x29c <_poll_dre_done>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:445
          if (_tx_buffer_head == _tx_buffer_tail) {
     282:	91 89       	ldd	r25, Z+17	; 0x11
     284:	82 89       	ldd	r24, Z+18	; 0x12
     286:	98 13       	cpse	r25, r24
     288:	07 c0       	rjmp	.+14     	; 0x298 <HardwareSerial::_poll_tx_data_empty()+0x34>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:447
            // Buffer empty, so disable "data register empty" interrupt
            (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     28a:	15 96       	adiw	r26, 0x05	; 5
     28c:	8c 91       	ld	r24, X
     28e:	15 97       	sbiw	r26, 0x05	; 5
     290:	8f 7d       	andi	r24, 0xDF	; 223
     292:	15 96       	adiw	r26, 0x05	; 5
     294:	8c 93       	st	X, r24
     296:	08 95       	ret
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:465
      #else
                    "rjmp _poll_dre"    "\n\t"
      #endif
                    "_poll_dre_done:"    "\n"
                    ::"z"((uint16_t)thisSerial)
                    : "r18","r19","r24","r25","r26","r27"); // these got saved and restored in the ISR context, but here we don't need top and in many cases no action is needed.
     298:	e8 94       	clt
     29a:	81 c5       	rjmp	.+2818   	; 0xd9e <_poll_dre>

0000029c <_poll_dre_done>:
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:474
        }
      }
      // In case interrupts are enabled, the interrupt routine will be invoked by itself
      // Note that this currently does not handle cases where the DRE interruopt becomes
      // disabled, yet you are actually attempting to send. I don't think it can happen.
    }
     29c:	08 95       	ret

0000029e <HardwareSerial::write(unsigned char)>:
_ZN14HardwareSerial5writeEh():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:767
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }


      size_t HardwareSerial::write(uint8_t c) {
     29e:	0f 93       	push	r16
     2a0:	1f 93       	push	r17
     2a2:	cf 93       	push	r28
     2a4:	df 93       	push	r29
     2a6:	ec 01       	movw	r28, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:768
        _state |= 1; // Record that we have written to serial since it was begun.
     2a8:	8e 85       	ldd	r24, Y+14	; 0x0e
     2aa:	81 60       	ori	r24, 0x01	; 1
     2ac:	8e 87       	std	Y+14, r24	; 0x0e
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:773
        // If the buffer and the data register is empty, just write the byte
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     2ae:	99 89       	ldd	r25, Y+17	; 0x11
     2b0:	8a 89       	ldd	r24, Y+18	; 0x12
     2b2:	98 13       	cpse	r25, r24
     2b4:	0b c0       	rjmp	.+22     	; 0x2cc <HardwareSerial::write(unsigned char)+0x2e>
     2b6:	e8 85       	ldd	r30, Y+8	; 0x08
     2b8:	f9 85       	ldd	r31, Y+9	; 0x09
     2ba:	84 81       	ldd	r24, Z+4	; 0x04
     2bc:	85 ff       	sbrs	r24, 5
     2be:	06 c0       	rjmp	.+12     	; 0x2cc <HardwareSerial::write(unsigned char)+0x2e>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:774
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     2c0:	8e 85       	ldd	r24, Y+14	; 0x0e
     2c2:	81 fd       	sbrc	r24, 1
     2c4:	0d c0       	rjmp	.+26     	; 0x2e0 <HardwareSerial::write(unsigned char)+0x42>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:781
            ctrla &= ~USART_RXCIE_bm;
            ctrla |=  USART_TXCIE_bm;
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
            (*_hwserial_module).CTRLA = ctrla;
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     2c6:	80 e4       	ldi	r24, 0x40	; 64
     2c8:	84 83       	std	Z+4, r24	; 0x04
     2ca:	12 c0       	rjmp	.+36     	; 0x2f0 <HardwareSerial::write(unsigned char)+0x52>
     2cc:	06 2f       	mov	r16, r22
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:802
           * // that the interrupt handler is called in this situation
           * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
           */
          return 1;
        }
        tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
     2ce:	19 89       	ldd	r17, Y+17	; 0x11
     2d0:	1f 5f       	subi	r17, 0xFF	; 255
     2d2:	1f 73       	andi	r17, 0x3F	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:806

        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
     2d4:	8a 89       	ldd	r24, Y+18	; 0x12
     2d6:	81 13       	cpse	r24, r17
     2d8:	15 c0       	rjmp	.+42     	; 0x304 <HardwareSerial::write(unsigned char)+0x66>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:807
          _poll_tx_data_empty();
     2da:	ce 01       	movw	r24, r28
     2dc:	c3 df       	rcall	.-122    	; 0x264 <HardwareSerial::_poll_tx_data_empty()>
     2de:	fa cf       	rjmp	.-12     	; 0x2d4 <HardwareSerial::write(unsigned char)+0x36>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:775
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
            uint8_t ctrla = (*_hwserial_module).CTRLA;
     2e0:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:776
            ctrla &= ~USART_RXCIE_bm;
     2e2:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:777
            ctrla |=  USART_TXCIE_bm;
     2e4:	80 64       	ori	r24, 0x40	; 64
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:778
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     2e6:	90 e4       	ldi	r25, 0x40	; 64
     2e8:	94 83       	std	Z+4, r25	; 0x04
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:779
            (*_hwserial_module).CTRLA = ctrla;
     2ea:	e8 85       	ldd	r30, Y+8	; 0x08
     2ec:	f9 85       	ldd	r31, Y+9	; 0x09
     2ee:	85 83       	std	Z+5, r24	; 0x05
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:784
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
          }
          // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
          (*_hwserial_module).TXDATAL = c;
     2f0:	e8 85       	ldd	r30, Y+8	; 0x08
     2f2:	f9 85       	ldd	r31, Y+9	; 0x09
     2f4:	62 83       	std	Z+2, r22	; 0x02
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:822
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
        }
        return 1;
      }
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	df 91       	pop	r29
     2fc:	cf 91       	pop	r28
     2fe:	1f 91       	pop	r17
     300:	0f 91       	pop	r16
     302:	08 95       	ret
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:809
        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
          _poll_tx_data_empty();
        }
        _tx_buffer[_tx_buffer_head] = c;
     304:	e9 89       	ldd	r30, Y+17	; 0x11
     306:	ec 0f       	add	r30, r28
     308:	fd 2f       	mov	r31, r29
     30a:	f1 1d       	adc	r31, r1
     30c:	ed 5a       	subi	r30, 0xAD	; 173
     30e:	ff 4f       	sbci	r31, 0xFF	; 255
     310:	00 83       	st	Z, r16
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:810
        _tx_buffer_head = i;
     312:	19 8b       	std	Y+17, r17	; 0x11
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:811
        if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     314:	8e 85       	ldd	r24, Y+14	; 0x0e
     316:	e8 85       	ldd	r30, Y+8	; 0x08
     318:	f9 85       	ldd	r31, Y+9	; 0x09
     31a:	81 ff       	sbrs	r24, 1
     31c:	09 c0       	rjmp	.+18     	; 0x330 <HardwareSerial::write(unsigned char)+0x92>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:812
          uint8_t ctrla = (*_hwserial_module).CTRLA;
     31e:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:813
          ctrla &= ~USART_RXCIE_bm;
     320:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:814
          ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
     322:	80 66       	ori	r24, 0x60	; 96
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:815
          (*_hwserial_module).STATUS = USART_TXCIF_bm;
     324:	90 e4       	ldi	r25, 0x40	; 64
     326:	94 83       	std	Z+4, r25	; 0x04
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:816
          (*_hwserial_module).CTRLA = ctrla;
     328:	e8 85       	ldd	r30, Y+8	; 0x08
     32a:	f9 85       	ldd	r31, Y+9	; 0x09
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:819
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     32c:	85 83       	std	Z+5, r24	; 0x05
     32e:	e3 cf       	rjmp	.-58     	; 0x2f6 <HardwareSerial::write(unsigned char)+0x58>
     330:	85 81       	ldd	r24, Z+5	; 0x05
     332:	80 62       	ori	r24, 0x20	; 32
     334:	fb cf       	rjmp	.-10     	; 0x32c <HardwareSerial::write(unsigned char)+0x8e>

00000336 <HardwareSerial::flush()>:
_ZN14HardwareSerial5flushEv():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:736
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
        }
        return tail - head - 1;
      }

      void HardwareSerial::flush() {
     336:	cf 93       	push	r28
     338:	df 93       	push	r29
     33a:	ec 01       	movw	r28, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:740
        // If we have never written a byte, no need to flush. This special
        // case is needed since there is no way to force the TXCIF (transmit
        // complete) bit to 1 during initialization
        if (!_state & 1) {
     33c:	8e 85       	ldd	r24, Y+14	; 0x0e
     33e:	88 23       	and	r24, r24
     340:	59 f0       	breq	.+22     	; 0x358 <HardwareSerial::flush()+0x22>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:755
        // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
        // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
        // and in that case flush(), and write() with full buffer would just straight up hang...

        // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
        while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     342:	e8 85       	ldd	r30, Y+8	; 0x08
     344:	f9 85       	ldd	r31, Y+9	; 0x09
     346:	85 81       	ldd	r24, Z+5	; 0x05
     348:	85 fd       	sbrc	r24, 5
     34a:	03 c0       	rjmp	.+6      	; 0x352 <HardwareSerial::flush()+0x1c>
     34c:	84 81       	ldd	r24, Z+4	; 0x04
     34e:	86 fd       	sbrc	r24, 6
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:760

          // If interrupts are globally disabled or the and DR empty interrupt is disabled,
          // poll the "data register empty" interrupt flag to prevent deadlock

          _poll_tx_data_empty();
     350:	03 c0       	rjmp	.+6      	; 0x358 <HardwareSerial::flush()+0x22>
     352:	ce 01       	movw	r24, r28
     354:	87 df       	rcall	.-242    	; 0x264 <HardwareSerial::_poll_tx_data_empty()>
     356:	f5 cf       	rjmp	.-22     	; 0x342 <HardwareSerial::flush()+0xc>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:764
        }
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }
     358:	df 91       	pop	r29
     35a:	cf 91       	pop	r28
     35c:	08 95       	ret

0000035e <_delayMicroseconds>:
_delayMicroseconds():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1174
  us -= 3; // 2 cycles


#elif F_CPU >= 24000000L
  // for a one-microsecond delay, burn 8 cycles and return
  __asm__ __volatile__ (
     35e:	01 c0       	rjmp	.+2      	; 0x362 <_delayMicroseconds+0x4>
     360:	08 95       	ret
     362:	fe df       	rcall	.-4      	; 0x360 <_delayMicroseconds+0x2>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1179
    "rjmp .+2" "\n\t"     // 2 cycles - jump over next instruction.
    "ret" "\n\t"          // 4 cycles - rjmped over initially....
    "rcall .-4");         // 2 cycles - ... but then called here);
                          // wait 8 cycles with 3 words
  if (us <= 1) return; //  = 3 cycles, (4 when true)
     364:	82 30       	cpi	r24, 0x02	; 2
     366:	91 05       	cpc	r25, r1
     368:	50 f0       	brcs	.+20     	; 0x37e <_delayMicroseconds+0x20>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1183

  // the loop takes 1/3 of a microsecond (8 cycles) per iteration
  // so execute it three times for each microsecond of delay requested.
  us = (us << 1) + us; // x3 us, = 5 cycles
     36a:	9c 01       	movw	r18, r24
     36c:	22 0f       	add	r18, r18
     36e:	33 1f       	adc	r19, r19
     370:	03 97       	sbiw	r24, 0x03	; 3
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1185
  // we just burned 24 (22) cycles above, remove 3
  us -= 3; // 2 cycles
     372:	82 0f       	add	r24, r18
     374:	93 1f       	adc	r25, r19
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1317
    "rjmp .+0"      "\n\t"            // 2 cycles
    "nop"           "\n\t"
    "brne 1b" : "=w" (us) : "0" (us)  // 2 cycles
  );
#elif defined(DELAYMICROS_EIGHT)
  __asm__ __volatile__ (
     376:	01 97       	sbiw	r24, 0x01	; 1
     378:	00 c0       	rjmp	.+0      	; 0x37a <_delayMicroseconds+0x1c>
     37a:	00 c0       	rjmp	.+0      	; 0x37c <_delayMicroseconds+0x1e>
     37c:	e1 f7       	brne	.-8      	; 0x376 <_delayMicroseconds+0x18>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1343
    "1: sbiw %0, 1" "\n\t"            // 2 cycles
    "brne 1b" : "=w" (us) : "0" (us)  // 2 cycles
  );
#endif
  // return = 4 cycles
}
     37e:	08 95       	ret

00000380 <micros>:
micros():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:476
      #else /* TCA */
        uint8_t ticks;
      #endif
      uint8_t flags;
      /* Save current state and disable interrupts */
      uint8_t oldSREG = SREG;
     380:	9f b7       	in	r25, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:477
      cli(); /* INTERRUPTS OFF */
     382:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:493
        while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
        flags = TCD0.INTFLAGS;
        ticks = TCD0.CAPTUREA;
        */
      #else /* = defined(MILLIS_USE_TCB) */
        ticks = _timer->CNT;
     384:	e0 91 2a 0b 	lds	r30, 0x0B2A	; 0x800b2a <__TEXT_REGION_LENGTH__+0x7f0b2a>
     388:	f0 91 2b 0b 	lds	r31, 0x0B2B	; 0x800b2b <__TEXT_REGION_LENGTH__+0x7f0b2b>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:494
        flags = _timer->INTFLAGS;
     38c:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7f0b26>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:502
       * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
       * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
       * doesn't matter.
       * Get current number of overflows and timer count */
      #if defined(MILLIS_USE_TCB)
        overflows = timingStruct.timer_millis;
     390:	20 91 f7 60 	lds	r18, 0x60F7	; 0x8060f7 <timingStruct>
     394:	30 91 f8 60 	lds	r19, 0x60F8	; 0x8060f8 <timingStruct+0x1>
     398:	40 91 f9 60 	lds	r20, 0x60F9	; 0x8060f9 <timingStruct+0x2>
     39c:	50 91 fa 60 	lds	r21, 0x60FA	; 0x8060fa <timingStruct+0x3>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:507
      #else
        overflows = timingStruct.timer_overflow_count;
      #endif
      /* Turn interrupts back on, assuming they were on when micros was called. */
      SREG = oldSREG; /* INTERRUPTS ON */
     3a0:	9f bf       	out	0x3f, r25	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:517
      */
      #if defined(MILLIS_USE_TCA)
        ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
        if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x03)) {
      #else /* = defined(MILLIS_USE_TCB) */
        if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
     3a2:	80 ff       	sbrs	r24, 0
     3a4:	08 c0       	rjmp	.+16     	; 0x3b6 <micros+0x36>
     3a6:	cf 01       	movw	r24, r30
     3a8:	88 27       	eor	r24, r24
     3aa:	89 2b       	or	r24, r25
     3ac:	21 f4       	brne	.+8      	; 0x3b6 <micros+0x36>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:522
      #endif
      #if (defined(MILLIS_USE_TCB) && (F_CPU <= 2000000UL))
        overflows += 2;
      #else
        overflows++;
     3ae:	2f 5f       	subi	r18, 0xFF	; 255
     3b0:	3f 4f       	sbci	r19, 0xFF	; 255
     3b2:	4f 4f       	sbci	r20, 0xFF	; 255
     3b4:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:671
         * 57 replaced with 30 save 27 clocks @ 12 = 2 us saved
         * 67 replaced with 32 save 35 clocks @ 24 = 1.5us saved
         * 77 replaced with 34 save 43 clocks @ 48 = 1 us saved
         */
        #elif (F_CPU == 48000000UL || F_CPU == 24000000UL || F_CPU == 12000000UL || F_CPU == 6000000UL || F_CPU == 3000000UL)
          __asm__ __volatile__(
     3b6:	0f 01       	movw	r0, r30
     3b8:	16 94       	lsr	r1
     3ba:	07 94       	ror	r0
     3bc:	16 94       	lsr	r1
     3be:	07 94       	ror	r0
     3c0:	16 94       	lsr	r1
     3c2:	07 94       	ror	r0
     3c4:	16 94       	lsr	r1
     3c6:	07 94       	ror	r0
     3c8:	f0 01       	movw	r30, r0
     3ca:	16 94       	lsr	r1
     3cc:	07 94       	ror	r0
     3ce:	e0 0d       	add	r30, r0
     3d0:	f1 1d       	adc	r31, r1
     3d2:	16 94       	lsr	r1
     3d4:	07 94       	ror	r0
     3d6:	10 2c       	mov	r1, r0
     3d8:	16 94       	lsr	r1
     3da:	01 18       	sub	r0, r1
     3dc:	16 94       	lsr	r1
     3de:	01 0c       	add	r0, r1
     3e0:	16 94       	lsr	r1
     3e2:	01 18       	sub	r0, r1
     3e4:	16 94       	lsr	r1
     3e6:	01 0c       	add	r0, r1
     3e8:	16 94       	lsr	r1
     3ea:	01 18       	sub	r0, r1
     3ec:	16 94       	lsr	r1
     3ee:	16 94       	lsr	r1
     3f0:	01 0c       	add	r0, r1
     3f2:	11 24       	eor	r1, r1
     3f4:	e0 19       	sub	r30, r0
     3f6:	f1 09       	sbc	r31, r1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:716
            "add r0,r1"     "\n\t"  // + ticks >> 9
            "eor r1,r1"     "\n\t"  // clear out r1
            "sub %A0,r0"    "\n\t"  // Add the sum of terms that fit in a byte to what was ticks in old code.
            "sbc %B0,r1"    "\n"    // carry - see,this is why AVR needs a known zero.
            : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
          microseconds = overflows * 1000 + ticks; // nice and clean.
     3f8:	a8 ee       	ldi	r26, 0xE8	; 232
     3fa:	b3 e0       	ldi	r27, 0x03	; 3
     3fc:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__muluhisi3>
     400:	6e 0f       	add	r22, r30
     402:	7f 1f       	adc	r23, r31
     404:	81 1d       	adc	r24, r1
     406:	91 1d       	adc	r25, r1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:886
          microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                        + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
        #endif
      #endif // end of timer-specific part of micros calculations
      return microseconds;
    }
     408:	08 95       	ret

0000040a <delay>:
delay():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:948

#if (!(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC) || (F_CPU == 7000000L || F_CPU == 14000000)))
  // delay implementation when we do have micros() - we know it won't work at 7 or 14, and those can be generated
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
     40a:	cf 92       	push	r12
     40c:	df 92       	push	r13
     40e:	ef 92       	push	r14
     410:	ff 92       	push	r15
     412:	cf 93       	push	r28
     414:	df 93       	push	r29
     416:	6b 01       	movw	r12, r22
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:949
    uint16_t start = (uint16_t)micros();
     418:	7c 01       	movw	r14, r24
     41a:	b2 df       	rcall	.-156    	; 0x380 <micros>
     41c:	eb 01       	movw	r28, r22
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:953
    while (true) {
      if (ms == 0) break;
      yield();
      uint16_t us_passed = (uint16_t)micros() - start;
     41e:	b0 df       	rcall	.-160    	; 0x380 <micros>
     420:	6c 1b       	sub	r22, r28
     422:	7d 0b       	sbc	r23, r29
     424:	68 3e       	cpi	r22, 0xE8	; 232
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:954
      if (us_passed >= 1000) {
     426:	73 40       	sbci	r23, 0x03	; 3
     428:	d0 f3       	brcs	.-12     	; 0x41e <delay+0x14>
     42a:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:955
        ms--;
     42c:	c8 1a       	sub	r12, r24
     42e:	d1 08       	sbc	r13, r1
     430:	e1 08       	sbc	r14, r1
     432:	f1 08       	sbc	r15, r1
     434:	c8 51       	subi	r28, 0x18	; 24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:956
        start += 1000;
     436:	dc 4f       	sbci	r29, 0xFC	; 252
     438:	c1 14       	cp	r12, r1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:951
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
    while (true) {
      if (ms == 0) break;
     43a:	d1 04       	cpc	r13, r1
     43c:	e1 04       	cpc	r14, r1
     43e:	f1 04       	cpc	r15, r1
     440:	71 f7       	brne	.-36     	; 0x41e <delay+0x14>
     442:	df 91       	pop	r29
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:959
      if (us_passed >= 1000) {
        ms--;
        start += 1000;
      }
    }
  }
     444:	cf 91       	pop	r28
     446:	ff 90       	pop	r15
     448:	ef 90       	pop	r14
     44a:	df 90       	pop	r13
     44c:	cf 90       	pop	r12
     44e:	08 95       	ret

00000450 <Print::write(char const*) [clone .part.2] [clone .constprop.65]>:
_ZN5Print5writeEPKc.part.2.constprop.65():
     450:	fc 01       	movw	r30, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.h:56
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
     452:	01 90       	ld	r0, Z+
     454:	00 20       	and	r0, r0
     456:	e9 f7       	brne	.-6      	; 0x452 <Print::write(char const*) [clone .part.2] [clone .constprop.65]+0x2>
     458:	31 97       	sbiw	r30, 0x01	; 1
     45a:	af 01       	movw	r20, r30
     45c:	48 1b       	sub	r20, r24
     45e:	59 0b       	sbc	r21, r25
     460:	bc 01       	movw	r22, r24
     462:	8b ef       	ldi	r24, 0xFB	; 251
     464:	90 e6       	ldi	r25, 0x60	; 96
     466:	94 ce       	rjmp	.-728    	; 0x190 <Print::write(unsigned char const*, unsigned int)>

00000468 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.57]>:
_ZN5Print11printNumberEmh.constprop.57():
     468:	8f 92       	push	r8
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:215
  return vfprintf_P(&f, (const char *)format, ap);
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
     46a:	9f 92       	push	r9
     46c:	af 92       	push	r10
     46e:	bf 92       	push	r11
     470:	0f 93       	push	r16
     472:	1f 93       	push	r17
     474:	cf 93       	push	r28
     476:	df 93       	push	r29
     478:	cd b7       	in	r28, 0x3d	; 61
     47a:	de b7       	in	r29, 0x3e	; 62
     47c:	a1 97       	sbiw	r28, 0x21	; 33
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	de bf       	out	0x3e, r29	; 62
     482:	19 a2       	std	Y+33, r1	; 0x21
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:219
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     484:	42 30       	cpi	r20, 0x02	; 2
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:222

  // prevent crash if called with base == 1
  if (base < 2) {
     486:	08 f4       	brcc	.+2      	; 0x48a <Print::printNumber(unsigned long, unsigned char) [clone .constprop.57]+0x22>
     488:	4a e0       	ldi	r20, 0x0A	; 10
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:223
    base = 10;
     48a:	8e 01       	movw	r16, r28
     48c:	0f 5d       	subi	r16, 0xDF	; 223
     48e:	1f 4f       	sbci	r17, 0xFF	; 255
     490:	84 2e       	mov	r8, r20
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:227
  }

  do {
    char c = n % base;
     492:	91 2c       	mov	r9, r1
     494:	b1 2c       	mov	r11, r1
     496:	a1 2c       	mov	r10, r1
     498:	a5 01       	movw	r20, r10
     49a:	94 01       	movw	r18, r8
     49c:	0e 94 aa 0a 	call	0x1554	; 0x1554 <__udivmodsi4>
     4a0:	e6 2f       	mov	r30, r22
     4a2:	b9 01       	movw	r22, r18
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:228
    n /= base;
     4a4:	ca 01       	movw	r24, r20
     4a6:	ea 30       	cpi	r30, 0x0A	; 10
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:230

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     4a8:	d4 f4       	brge	.+52     	; 0x4de <Print::printNumber(unsigned long, unsigned char) [clone .constprop.57]+0x76>
     4aa:	e0 5d       	subi	r30, 0xD0	; 208
     4ac:	d8 01       	movw	r26, r16
     4ae:	ee 93       	st	-X, r30
     4b0:	8d 01       	movw	r16, r26
     4b2:	23 2b       	or	r18, r19
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:231
  } while (n);
     4b4:	24 2b       	or	r18, r20
     4b6:	25 2b       	or	r18, r21
     4b8:	79 f7       	brne	.-34     	; 0x498 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.57]+0x30>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.h:54
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	80 e0       	ldi	r24, 0x00	; 0
write():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.h:53
      setWriteError(0);
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
     4be:	10 97       	sbiw	r26, 0x00	; 0
     4c0:	11 f0       	breq	.+4      	; 0x4c6 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.57]+0x5e>
     4c2:	cd 01       	movw	r24, r26
     4c4:	c5 df       	rcall	.-118    	; 0x450 <Print::write(char const*) [clone .part.2] [clone .constprop.65]>
_ZN5Print11printNumberEmh.constprop.57():
     4c6:	a1 96       	adiw	r28, 0x21	; 33
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:234

  return write(str);
}
     4c8:	cd bf       	out	0x3d, r28	; 61
     4ca:	de bf       	out	0x3e, r29	; 62
     4cc:	df 91       	pop	r29
     4ce:	cf 91       	pop	r28
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	bf 90       	pop	r11
     4d6:	af 90       	pop	r10
     4d8:	9f 90       	pop	r9
     4da:	8f 90       	pop	r8
     4dc:	08 95       	ret
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:230

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     4de:	e9 5c       	subi	r30, 0xC9	; 201
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:133
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[]) {
     4e0:	e5 cf       	rjmp	.-54     	; 0x4ac <Print::printNumber(unsigned long, unsigned char) [clone .constprop.57]+0x44>

000004e2 <Print::println(char const*) [clone .constprop.62]>:
_ZN5Print7printlnEPKc.constprop.62():
     4e2:	cf 93       	push	r28
     4e4:	df 93       	push	r29
write():
     4e6:	b4 df       	rcall	.-152    	; 0x450 <Print::write(char const*) [clone .part.2] [clone .constprop.65]>
     4e8:	ec 01       	movw	r28, r24
     4ea:	87 ea       	ldi	r24, 0xA7	; 167
     4ec:	90 e6       	ldi	r25, 0x60	; 96
     4ee:	b0 df       	rcall	.-160    	; 0x450 <Print::write(char const*) [clone .part.2] [clone .constprop.65]>
_ZN5Print7printlnEPKc.constprop.62():
     4f0:	8c 0f       	add	r24, r28
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Print.cpp:137
  size_t n = print(c);
  n += println();
  return n;
}
     4f2:	9d 1f       	adc	r25, r29
     4f4:	df 91       	pop	r29
     4f6:	cf 91       	pop	r28
     4f8:	08 95       	ret

000004fa <digitalRead>:
digitalRead():
     4fa:	28 2f       	mov	r18, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/Arduino.h:800
  #if !defined(NUM_TOTAL_PINS)
    #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
  #endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
     4fc:	30 e0       	ldi	r19, 0x00	; 0
     4fe:	8c 31       	cpi	r24, 0x1C	; 28
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:323
}

int8_t digitalRead(uint8_t pin) {
  check_valid_digital_pin(pin);
  /* Get bit mask and check valid pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     500:	a8 f4       	brcc	.+42     	; 0x52c <digitalRead+0x32>
     502:	f9 01       	movw	r30, r18
     504:	ef 5c       	subi	r30, 0xCF	; 207
     506:	ff 49       	sbci	r31, 0x9F	; 159
     508:	80 81       	ld	r24, Z
     50a:	8f 3f       	cpi	r24, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:324
  if (bit_mask == NOT_A_PIN) {
     50c:	79 f0       	breq	.+30     	; 0x52c <digitalRead+0x32>
     50e:	23 5a       	subi	r18, 0xA3	; 163
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:337
  // high bar for stuff that would make it even slower than it already is.
  //
  // turnOffPWM(pin);

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);
     510:	3f 49       	sbci	r19, 0x9F	; 159
     512:	d9 01       	movw	r26, r18
     514:	ec 91       	ld	r30, X
     516:	b0 e2       	ldi	r27, 0x20	; 32
     518:	eb 9f       	mul	r30, r27
     51a:	f0 01       	movw	r30, r0
     51c:	11 24       	eor	r1, r1
     51e:	fc 5f       	subi	r31, 0xFC	; 252
     520:	90 85       	ldd	r25, Z+8	; 0x08
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:340

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
     522:	98 23       	and	r25, r24
     524:	81 e0       	ldi	r24, 0x01	; 1
     526:	19 f4       	brne	.+6      	; 0x52e <digitalRead+0x34>
     528:	80 e0       	ldi	r24, 0x00	; 0
     52a:	08 95       	ret
     52c:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:325
int8_t digitalRead(uint8_t pin) {
  check_valid_digital_pin(pin);
  /* Get bit mask and check valid pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
  if (bit_mask == NOT_A_PIN) {
    return -1;
     52e:	08 95       	ret

00000530 <digitalWrite>:
digitalWrite():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:345
  if (port->IN & bit_mask) {
    return HIGH;
  } else {
    return LOW;
  }
}
     530:	0f 93       	push	r16
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:209
  default:
    break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
     532:	1f 93       	push	r17
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	8c 31       	cpi	r24, 0x1C	; 28
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:212
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     53a:	08 f0       	brcs	.+2      	; 0x53e <digitalWrite+0xe>
     53c:	b2 c0       	rjmp	.+356    	; 0x6a2 <digitalWrite+0x172>
check_valid_digital_pin():
     53e:	90 e0       	ldi	r25, 0x00	; 0
digitalWrite():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/Arduino.h:800
     540:	dc 01       	movw	r26, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:212
     542:	af 5c       	subi	r26, 0xCF	; 207
     544:	bf 49       	sbci	r27, 0x9F	; 159
     546:	2c 91       	ld	r18, X
     548:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:213
  if (bit_mask == NOT_A_PIN) {
     54a:	09 f4       	brne	.+2      	; 0x54e <digitalWrite+0x1e>
     54c:	aa c0       	rjmp	.+340    	; 0x6a2 <digitalWrite+0x172>
     54e:	8c 01       	movw	r16, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:218
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
     550:	03 5a       	subi	r16, 0xA3	; 163
     552:	1f 49       	sbci	r17, 0x9F	; 159
     554:	e8 01       	movw	r28, r16
     556:	e8 81       	ld	r30, Y
     558:	d0 e2       	ldi	r29, 0x20	; 32
     55a:	ed 9f       	mul	r30, r29
     55c:	f0 01       	movw	r30, r0
     55e:	11 24       	eor	r1, r1
     560:	fc 5f       	subi	r31, 0xFC	; 252
     562:	61 11       	cpse	r22, r1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:226
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
     564:	32 c0       	rjmp	.+100    	; 0x5ca <digitalWrite+0x9a>
     566:	26 83       	std	Z+6, r18	; 0x06
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:227
    port->OUTCLR = bit_mask;
     568:	30 81       	ld	r19, Z
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:251
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
     56a:	23 23       	and	r18, r19
     56c:	ac 01       	movw	r20, r24
     56e:	47 58       	subi	r20, 0x87	; 135
     570:	5f 49       	sbci	r21, 0x9F	; 159
     572:	21 11       	cpse	r18, r1
     574:	11 c0       	rjmp	.+34     	; 0x598 <digitalWrite+0x68>
     576:	ea 01       	movw	r28, r20
     578:	28 81       	ld	r18, Y
     57a:	30 97       	sbiw	r30, 0x00	; 0
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:261

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     57c:	79 f1       	breq	.+94     	; 0x5dc <digitalWrite+0xac>
     57e:	28 30       	cpi	r18, 0x08	; 8
     580:	68 f5       	brcc	.+90     	; 0x5dc <digitalWrite+0xac>
     582:	70 96       	adiw	r30, 0x10	; 16
     584:	e2 0f       	add	r30, r18
     586:	f1 1d       	adc	r31, r1
     588:	3f b7       	in	r19, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:264

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     58a:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:265
    cli();
     58c:	20 81       	ld	r18, Z
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:269

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     58e:	61 11       	cpse	r22, r1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:267

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
     590:	28 c0       	rjmp	.+80     	; 0x5e2 <digitalWrite+0xb2>
     592:	27 7f       	andi	r18, 0xF7	; 247
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:269
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     594:	20 83       	st	Z, r18
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:272
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     596:	3f bf       	out	0x3f, r19	; 63
digitalPinToTimerNow():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:276
    }

    /* Restore system status */
    SREG = status;
     598:	fa 01       	movw	r30, r20
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:745
  badCall("Resuming core control of type D timer not supported.");
}


uint8_t digitalPinToTimerNow(uint8_t p) {
  uint8_t bit_pos = digitalPinToBitPosition(p);
     59a:	30 81       	ld	r19, Z
     59c:	3f 3f       	cpi	r19, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:746
  if (bit_pos == NOT_A_PIN) return NOT_ON_TIMER;     /* Use bit position to check for invalid pins */
     59e:	09 f4       	brne	.+2      	; 0x5a2 <digitalWrite+0x72>
     5a0:	80 c0       	rjmp	.+256    	; 0x6a2 <digitalWrite+0x172>
     5a2:	e8 01       	movw	r28, r16
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:747
  uint8_t port = digitalPinToPort(p);                /* If bit_pos is valid, port will be too      */
     5a4:	28 81       	ld	r18, Y
     5a6:	36 30       	cpi	r19, 0x06	; 6
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:748
  if ( bit_pos < 6) {                                /* SPLIT MODE TCA output is on pins 0-5       */
     5a8:	f0 f4       	brcc	.+60     	; 0x5e6 <digitalWrite+0xb6>
     5aa:	30 91 e7 05 	lds	r19, 0x05E7	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7f05e7>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:764
        return TIMERA1;                              /* mux options, not 3-channel ones on bit 4:6 */
      }
    }
  #else
    if (__PeripheralControl & TIMERA0) {               /* here we don't need to store tcamux */
      if ((PORTMUX.TCAROUTEA & PORTMUX_TCA0_gm) == port) { /* because it is only used once */
     5ae:	37 70       	andi	r19, 0x07	; 7
     5b0:	23 13       	cpse	r18, r19
     5b2:	19 c0       	rjmp	.+50     	; 0x5e6 <digitalWrite+0xb6>
turnOffPWM():
     5b4:	ec 91       	ld	r30, X
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
     5b6:	e5 30       	cpi	r30, 0x05	; 5
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:128
  switch (timer) {

  /* TCA0 */
  case TIMERA0:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; // there's a blank bit in the middle
     5b8:	08 f0       	brcs	.+2      	; 0x5bc <digitalWrite+0x8c>
     5ba:	ee 0f       	add	r30, r30
     5bc:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f0a01>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:130
    /* Disable corresponding channel */
    TCA0.SPLIT.CTRLB &= ~bit_mask;
     5c0:	e0 95       	com	r30
     5c2:	e8 23       	and	r30, r24
     5c4:	e0 93 01 0a 	sts	0x0A01, r30	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f0a01>
     5c8:	6c c0       	rjmp	.+216    	; 0x6a2 <digitalWrite+0x172>
digitalWrite():
     5ca:	64 30       	cpi	r22, 0x04	; 4
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:228
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
  } else if (val == CHANGE) { /* If TOGGLE
     5cc:	29 f4       	brne	.+10     	; 0x5d8 <digitalWrite+0xa8>
     5ce:	34 81       	ldd	r19, Z+4	; 0x04
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:235
     * we need to know if it's been set high or low
     * otherwise the pullup state could get out of
     * sync with the output bit. Annoying! But we should
     * have to read it before writing OUTTGL, since that can
     * have a 1 clock delay. So read first + invert */
    val = !(port->OUT & bit_mask);
     5d0:	27 83       	std	Z+7, r18	; 0x07
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:236
    port->OUTTGL = bit_mask;
     5d2:	64 81       	ldd	r22, Z+4	; 0x04
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:241
    // Now, for the pullup setting part below
    // we need to know if it's been set high or low
    // otherwise the pullup state could get out of
    // sync with the output bit. Annoying!
    val = port->OUT & bit_mask;
     5d4:	62 23       	and	r22, r18
     5d6:	c8 cf       	rjmp	.-112    	; 0x568 <digitalWrite+0x38>
     5d8:	25 83       	std	Z+5, r18	; 0x05
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:247
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
     5da:	c6 cf       	rjmp	.-116    	; 0x568 <digitalWrite+0x38>
     5dc:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:261

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     5de:	e0 e0       	ldi	r30, 0x00	; 0
     5e0:	d3 cf       	rjmp	.-90     	; 0x588 <digitalWrite+0x58>
     5e2:	28 60       	ori	r18, 0x08	; 8
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:272
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     5e4:	d7 cf       	rjmp	.-82     	; 0x594 <digitalWrite+0x64>
digitalPinToTimerNow():
     5e6:	8b 5e       	subi	r24, 0xEB	; 235
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:770
        return TIMERA0;
      }
    }
  #endif
  }
  uint8_t timer = digitalPinToTimer(p);
     5e8:	9f 49       	sbci	r25, 0x9F	; 159
     5ea:	fc 01       	movw	r30, r24
     5ec:	80 81       	ld	r24, Z
     5ee:	86 ff       	sbrs	r24, 6
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:773

  if ( __PeripheralControl & TIMERD0) {
    if (timer & TIMERD0) {
     5f0:	42 c0       	rjmp	.+132    	; 0x676 <digitalWrite+0x146>
     5f2:	90 91 e9 05 	lds	r25, 0x05E9	; 0x8005e9 <__TEXT_REGION_LENGTH__+0x7f05e9>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:774
      byte tcdmux = (PORTMUX.TCDROUTEA & PORTMUX_TCD0_gm);
     5f6:	97 70       	andi	r25, 0x07	; 7
     5f8:	48 2f       	mov	r20, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:773
  #endif
  }
  uint8_t timer = digitalPinToTimer(p);

  if ( __PeripheralControl & TIMERD0) {
    if (timer & TIMERD0) {
     5fa:	50 e0       	ldi	r21, 0x00	; 0
     5fc:	4f 7b       	andi	r20, 0xBF	; 191
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:775
      byte tcdmux = (PORTMUX.TCDROUTEA & PORTMUX_TCD0_gm);
      if (tcdmux == (timer & ~TIMERD0)) {
     5fe:	94 17       	cp	r25, r20
     600:	15 06       	cpc	r1, r21
     602:	c9 f5       	brne	.+114    	; 0x676 <digitalWrite+0x146>
turnOffPWM():
     604:	ec 91       	ld	r30, X
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
     606:	80 91 92 0b 	lds	r24, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7f0b92>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:169
        uint8_t fcset = TCD0.FAULTCTRL & (bit_mask == 0x02 ? 0x80 : 0x40 );
      #else
        // on the DA series, it could be any of them
        #if !defined(ERRATA_TCD_PORTMUX) || ERRATA_TCD_PORTMUX == 0
          //                                Px4-Px7
          uint8_t fcset = TCD0.FAULTCTRL & (bit_mask > 0x0F ? bit_mask : bit_mask << 4 ); // hopefully that gets rendereed as swap, not 4 leftshifts
     60a:	9e 2f       	mov	r25, r30
     60c:	e0 31       	cpi	r30, 0x10	; 16
     60e:	10 f4       	brcc	.+4      	; 0x614 <digitalWrite+0xe4>
     610:	92 95       	swap	r25
     612:	90 7f       	andi	r25, 0xF0	; 240
     614:	89 23       	and	r24, r25
     616:	09 f4       	brne	.+2      	; 0x61a <digitalWrite+0xea>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:174
        #else
          uint8_t fcset = TCD0.FAULTCTRL & bit_mask;
        #endif
      #endif
      if (fcset) {
     618:	44 c0       	rjmp	.+136    	; 0x6a2 <digitalWrite+0x172>
     61a:	c0 e2       	ldi	r28, 0x20	; 32
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:179
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
     61c:	2c 9f       	mul	r18, r28
     61e:	90 01       	movw	r18, r0
     620:	11 24       	eor	r1, r1
     622:	3c 5f       	subi	r19, 0xFC	; 252
     624:	e8 30       	cpi	r30, 0x08	; 8
     626:	08 f0       	brcs	.+2      	; 0x62a <digitalWrite+0xfa>
     628:	52 c0       	rjmp	.+164    	; 0x6ce <digitalWrite+0x19e>
     62a:	20 5f       	subi	r18, 0xF0	; 240
     62c:	3f 4f       	sbci	r19, 0xFF	; 255
     62e:	e2 0f       	add	r30, r18
     630:	f3 2f       	mov	r31, r19
     632:	f1 1d       	adc	r31, r1
     634:	4f b7       	in	r20, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:188
        // it was currently set to output PWM, so it's very hard to imagine triggering it with just innocent calls to digitalWrite
        // in a constructor - we do not promise core functions will behave if users are reconfiguring peripherals in arbitrary ways.
        // Starting pwm manually (analogWrite won't start it until init starts the timers) in a constructor and then digitalWriting the same pin,
        // when the pin uses TCD0 for PWM is not expected to to produce correct behavior. If you modify the configuration except as described in
        // REF_TCD.md, you must takeOverTCD0() and assume full responsibility for all TCD configuration.
        uint8_t oldSREG = SREG;
     636:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:189
        cli();
     638:	90 91 80 0b 	lds	r25, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:190
        TCD0.CTRLA &= ~TCD_ENABLE_bm; // stop the timer
     63c:	9e 7f       	andi	r25, 0xFE	; 254
     63e:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
     642:	90 91 8e 0b 	lds	r25, 0x0B8E	; 0x800b8e <__TEXT_REGION_LENGTH__+0x7f0b8e>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:192
        // Experimentally found ENRDY must be set set to configure FAULTCTRL
        while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
     646:	90 ff       	sbrs	r25, 0
     648:	fc cf       	rjmp	.-8      	; 0x642 <digitalWrite+0x112>
     64a:	20 91 92 0b 	lds	r18, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7f0b92>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:193
        _PROTECTED_WRITE(TCD0.FAULTCTRL,TCD0.FAULTCTRL & ~fcset);
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	80 95       	com	r24
     652:	90 95       	com	r25
     654:	30 e0       	ldi	r19, 0x00	; 0
     656:	82 23       	and	r24, r18
     658:	93 23       	and	r25, r19
     65a:	28 ed       	ldi	r18, 0xD8	; 216
     65c:	24 bf       	out	0x34, r18	; 52
     65e:	80 93 92 0b 	sts	0x0B92, r24	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7f0b92>
     662:	80 91 80 0b 	lds	r24, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:195
        // while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
        TCD0.CTRLA |= TCD_ENABLE_bm;  // re-enable it
     666:	81 60       	ori	r24, 0x01	; 1
     668:	80 93 80 0b 	sts	0x0B80, r24	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
     66c:	80 81       	ld	r24, Z
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:197
        #if defined(NO_GLITCH_TIMERD0)
          *pin_ctrl_reg &= ~(PORT_INVEN_bm);
     66e:	8f 77       	andi	r24, 0x7F	; 127
     670:	80 83       	st	Z, r24
     672:	4f bf       	out	0x3f, r20	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:199
        #endif
        SREG = oldSREG;
     674:	16 c0       	rjmp	.+44     	; 0x6a2 <digitalWrite+0x172>
digitalPinToTimerNow():
     676:	85 ff       	sbrs	r24, 5
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:780
        return TIMERD0;
      }
    }
  }
  if (timer & TIMERB0) { /* Finally check TCBn, if we made it here w/out returning */
     678:	12 c0       	rjmp	.+36     	; 0x69e <digitalWrite+0x16e>
     67a:	30 e1       	ldi	r19, 0x10	; 16
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:782
    TCB_t* timer_B;
    timer_B = ((TCB_t *)&TCB0 + (timer - TIMERB0)); /* get timer struct */
     67c:	83 9f       	mul	r24, r19
     67e:	f0 01       	movw	r30, r0
     680:	11 24       	eor	r1, r1
     682:	f7 5f       	subi	r31, 0xF7	; 247
     684:	91 81       	ldd	r25, Z+1	; 0x01
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:783
    if (((timer_B->CTRLB) &  TCB_CNTMODE_gm) != TCB_CNTMODE_PWM8_gc )
     686:	97 70       	andi	r25, 0x07	; 7
     688:	97 30       	cpi	r25, 0x07	; 7
     68a:	59 f4       	brne	.+22     	; 0x6a2 <digitalWrite+0x172>
turnOffPWM():
     68c:	ec 91       	ld	r30, X
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
     68e:	85 32       	cpi	r24, 0x25	; 37
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:123
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
     690:	68 f4       	brcc	.+26     	; 0x6ac <digitalWrite+0x17c>
     692:	80 32       	cpi	r24, 0x20	; 32
     694:	98 f4       	brcc	.+38     	; 0x6bc <digitalWrite+0x18c>
     696:	80 31       	cpi	r24, 0x10	; 16
     698:	09 f4       	brne	.+2      	; 0x69c <digitalWrite+0x16c>
     69a:	8d cf       	rjmp	.-230    	; 0x5b6 <digitalWrite+0x86>
     69c:	02 c0       	rjmp	.+4      	; 0x6a2 <digitalWrite+0x172>
     69e:	81 11       	cpse	r24, r1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:116
{
  /* Actually turn off compare channel, not the timer */

  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;
     6a0:	f5 cf       	rjmp	.-22     	; 0x68c <digitalWrite+0x15c>
digitalWrite():
     6a2:	df 91       	pop	r29
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:289
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
     6a4:	cf 91       	pop	r28
     6a6:	1f 91       	pop	r17
     6a8:	0f 91       	pop	r16
     6aa:	08 95       	ret
turnOffPWM():
     6ac:	80 34       	cpi	r24, 0x40	; 64
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:123
  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
     6ae:	09 f4       	brne	.+2      	; 0x6b2 <digitalWrite+0x182>
     6b0:	aa cf       	rjmp	.-172    	; 0x606 <digitalWrite+0xd6>
     6b2:	80 38       	cpi	r24, 0x80	; 128
     6b4:	b1 f7       	brne	.-20     	; 0x6a2 <digitalWrite+0x172>
     6b6:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7f06a0>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:155
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);

    break;
  #if defined(DAC0)
  case DACOUT:
    DAC0.CTRLA = 0x00;
     6ba:	f3 cf       	rjmp	.-26     	; 0x6a2 <digitalWrite+0x172>
     6bc:	90 e1       	ldi	r25, 0x10	; 16
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:147
  case TIMERB1:
  case TIMERB2:
  case TIMERB3:
  case TIMERB4:

    timerB = (TCB_t *) &TCB0 + (timer - TIMERB0);
     6be:	89 9f       	mul	r24, r25
     6c0:	f0 01       	movw	r30, r0
     6c2:	11 24       	eor	r1, r1
     6c4:	f7 5f       	subi	r31, 0xF7	; 247
     6c6:	81 81       	ldd	r24, Z+1	; 0x01
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:150

     // Disable TCB compare channel
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);
     6c8:	8f 7e       	andi	r24, 0xEF	; 239
     6ca:	81 83       	std	Z+1, r24	; 0x01
     6cc:	ea cf       	rjmp	.-44     	; 0x6a2 <digitalWrite+0x172>
digitalWrite():
     6ce:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:179
      if (fcset) {
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
     6d0:	e0 e0       	ldi	r30, 0x00	; 0
     6d2:	b0 cf       	rjmp	.-160    	; 0x634 <digitalWrite+0x104>

000006d4 <RF24::csn(bool) [clone .constprop.50]>:
_ZN4RF243csnEb.constprop.50():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:15
#include "RF24_config.h"
#include "RF24.h"

/****************************************************************************/

void RF24::csn(bool mode)
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:94
    if (!mode)
        _SPI.chipSelect(csn_pin);
#endif // defined(RF24_RPi)

#if !defined(RF24_LINUX)
    digitalWrite(csn_pin, mode);
     6d8:	cb e9       	ldi	r28, 0x9B	; 155
     6da:	d1 e6       	ldi	r29, 0x61	; 97
     6dc:	68 2f       	mov	r22, r24
     6de:	8c 81       	ldd	r24, Y+4	; 0x04
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:981
inline __attribute__((always_inline)) void delayMicroseconds(unsigned int us) {
  // This function gets optimized away, but to what depends on whether us is constant.
  if (__builtin_constant_p(us)) {
    _delay_us(us); // Constant microseconds use the avr-libc _delay_us() which is highly accurate for all values and efficient!
  } else { // If it is not, we have to use the Arduino style implementation.
    _delayMicroseconds(us);
     6e0:	27 df       	rcall	.-434    	; 0x530 <digitalWrite>
delayMicroseconds():
     6e2:	8c 8d       	ldd	r24, Y+28	; 0x1c
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:99
    delayMicroseconds(csDelay);
#else
    static_cast<void>(mode); // ignore -Wunused-parameter
#endif // !defined(RF24_LINUX)
}
     6e4:	9d 8d       	ldd	r25, Y+29	; 0x1d
_ZN4RF243csnEb.constprop.50():
     6e6:	df 91       	pop	r29
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:981
     6e8:	cf 91       	pop	r28
delayMicroseconds():
     6ea:	39 ce       	rjmp	.-910    	; 0x35e <_delayMicroseconds>

000006ec <RF24::endTransaction() [clone .constprop.49]>:
_ZN4RF2414endTransactionEv.constprop.49():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:133

/****************************************************************************/

inline void RF24::endTransaction()
{
    csn(HIGH);
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	f2 df       	rcall	.-28     	; 0x6d4 <RF24::csn(bool) [clone .constprop.50]>
     6f0:	e0 91 9b 61 	lds	r30, 0x619B	; 0x80619b <radio>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:136
#if defined(RF24_SPI_TRANSACTIONS)
    #if defined(RF24_SPI_PTR)
    _spi->endTransaction();
     6f4:	f0 91 9c 61 	lds	r31, 0x619C	; 0x80619c <radio+0x1>
endTransaction():
     6f8:	82 85       	ldd	r24, Z+10	; 0x0a
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:564
  in_transaction = 1;
  config(settings);
}

void SPIClass::endTransaction(void) {
  if (in_transaction) {
     6fa:	88 23       	and	r24, r24
     6fc:	31 f0       	breq	.+12     	; 0x70a <RF24::endTransaction() [clone .constprop.49]+0x1e>
     6fe:	12 86       	std	Z+10, r1	; 0x0a
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:565
    in_transaction = 0;
     700:	80 85       	ldd	r24, Z+8	; 0x08
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:566
    if (interruptMode != SPI_IMODE_NONE) {
     702:	88 23       	and	r24, r24
     704:	11 f0       	breq	.+4      	; 0x70a <RF24::endTransaction() [clone .constprop.49]+0x1e>
     706:	81 85       	ldd	r24, Z+9	; 0x09
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:567
      SREG = old_sreg;
     708:	8f bf       	out	0x3f, r24	; 63
_ZN4RF2414endTransactionEv.constprop.49():
     70a:	08 95       	ret

0000070c <RF24::beginTransaction() [clone .constprop.45]>:
_ZN4RF2416beginTransactionEv.constprop.45():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:141
    #else  // !defined(RF24_SPI_PTR)
    _SPI.endTransaction();
    #endif // !defined(RF24_SPI_PTR)
#endif     // defined (RF24_SPI_TRANSACTIONS)
}
     70c:	0f 93       	push	r16
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:113
    }
}

/****************************************************************************/

inline void RF24::beginTransaction()
     70e:	1f 93       	push	r17
     710:	e0 91 9b 61 	lds	r30, 0x619B	; 0x80619b <radio>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:120
#if defined(RF24_SPI_TRANSACTIONS)
    #if defined(RF24_SPI_PTR)
        #if defined(RF24_RP2)
    _spi->beginTransaction(spi_speed);
        #else  // ! defined (RF24_RP2)
    _spi->beginTransaction(SPISettings(spi_speed, MSBFIRST, SPI_MODE0));
     714:	f0 91 9c 61 	lds	r31, 0x619C	; 0x80619c <radio+0x1>
     718:	00 91 a1 61 	lds	r16, 0x61A1	; 0x8061a1 <radio+0x6>
     71c:	10 91 a2 61 	lds	r17, 0x61A2	; 0x8061a2 <radio+0x7>
     720:	20 91 a3 61 	lds	r18, 0x61A3	; 0x8061a3 <radio+0x8>
     724:	30 91 a4 61 	lds	r19, 0x61A4	; 0x8061a4 <radio+0x9>
     728:	40 e0       	ldi	r20, 0x00	; 0
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:230
      /*  This is no longer the case since, F_CPU_CORRECTED is variable */
      /*  set at run time.                                             */

      uint32_t clockSetting = 0;

      clockSetting = F_CPU >> 1;
     72a:	5b e1       	ldi	r21, 0x1B	; 27
     72c:	67 eb       	ldi	r22, 0xB7	; 183
     72e:	70 e0       	ldi	r23, 0x00	; 0
     730:	80 e0       	ldi	r24, 0x00	; 0
_ZN11SPISettings17init_AlwaysInlineEmhh():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:231
      clockDiv = 0;
     732:	04 17       	cp	r16, r20
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:232
      while ((clockDiv < 6) && (clock < clockSetting)) {
     734:	15 07       	cpc	r17, r21
     736:	26 07       	cpc	r18, r22
     738:	37 07       	cpc	r19, r23
     73a:	40 f4       	brcc	.+16     	; 0x74c <RF24::beginTransaction() [clone .constprop.45]+0x40>
     73c:	76 95       	lsr	r23
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:233
        clockSetting >>= 1;
     73e:	67 95       	ror	r22
     740:	57 95       	ror	r21
     742:	47 95       	ror	r20
     744:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:234
        clockDiv++;
     746:	86 30       	cpi	r24, 0x06	; 6
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:232

      uint32_t clockSetting = 0;

      clockSetting = F_CPU >> 1;
      clockDiv = 0;
      while ((clockDiv < 6) && (clock < clockSetting)) {
     748:	a1 f7       	brne	.-24     	; 0x732 <RF24::beginTransaction() [clone .constprop.45]+0x26>
_ZN4RF2416beginTransactionEv.constprop.45():
     74a:	87 e0       	ldi	r24, 0x07	; 7
_ZN11SPISettings17init_AlwaysInlineEmhh():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:240
      }

      // Compensate for the duplicate fosc/64,
      // should be fosc/128 if clockdiv 6.
      if (clockDiv == 6) {
        clockDiv++;
     74c:	91 e0       	ldi	r25, 0x01	; 1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:244
      }

      // Invert the SPI2X bit
      clockDiv ^= 0x1;
     74e:	89 27       	eor	r24, r25
     750:	90 e1       	ldi	r25, 0x10	; 16
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:263
      //uint8_t clockDiv_pres = (clockDiv >> 1);

      /* Pack into the SPISettings::ctrlb class     */
      /* Set Prescaler, x2, SPI to Master, and Bit Order. */

      ctrla = (clockDiv & 1 ? SPI_CLK2X_bm : 0)       |
     752:	89 9f       	mul	r24, r25
     754:	90 01       	movw	r18, r0
     756:	11 24       	eor	r1, r1
     758:	20 71       	andi	r18, 0x10	; 16
     75a:	86 70       	andi	r24, 0x06	; 6
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:264
              (clockDiv & 6)                          |
     75c:	81 62       	ori	r24, 0x21	; 33
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.h:265
              (SPI_ENABLE_bm)                         |
     75e:	82 2b       	or	r24, r18
beginTransaction():
     760:	90 85       	ldd	r25, Z+8	; 0x08
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:555
  }
  interruptMode = SPI_IMODE_NONE;
}

void SPIClass::beginTransaction(SPISettings settings) {
  if (interruptMode != SPI_IMODE_NONE) {
     762:	99 23       	and	r25, r25
     764:	19 f0       	breq	.+6      	; 0x76c <RF24::beginTransaction() [clone .constprop.45]+0x60>
     766:	9f b7       	in	r25, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:556
    old_sreg = SREG;
     768:	91 87       	std	Z+9, r25	; 0x09
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:557
    cli(); // NoInterrupts();
     76a:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:559
  }
  in_transaction = 1;
     76c:	91 e0       	ldi	r25, 0x01	; 1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:385
  #endif
  initialized = true;
}

void SPIClass::config(SPISettings settings) {
  SPI_MODULE.CTRLA = settings.ctrla;
     76e:	92 87       	std	Z+10, r25	; 0x0a
config():
     770:	80 93 40 09 	sts	0x0940, r24	; 0x800940 <__TEXT_REGION_LENGTH__+0x7f0940>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:386
  SPI_MODULE.CTRLB = settings.ctrlb;
     774:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:126
        #endif // ! defined (RF24_RP2)
    #else      // !defined(RF24_SPI_PTR)
    _SPI.beginTransaction(SPISettings(spi_speed, MSBFIRST, SPI_MODE0));
    #endif     // !defined(RF24_SPI_PTR)
#endif         // defined (RF24_SPI_TRANSACTIONS)
    csn(LOW);
     776:	80 93 41 09 	sts	0x0941, r24	; 0x800941 <__TEXT_REGION_LENGTH__+0x7f0941>
_ZN4RF2416beginTransactionEv.constprop.45():
     77a:	80 e0       	ldi	r24, 0x00	; 0
     77c:	1f 91       	pop	r17
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:281
#endif     // !defined(RF24_LINUX) && !defined(RF24_RP2)
}

/****************************************************************************/

void RF24::write_register(uint8_t reg, uint8_t value, bool is_cmd_only)
     77e:	0f 91       	pop	r16
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:287
{
    if (is_cmd_only) {
        if (reg != RF24_NOP) { // don't print the get_status() operation
            IF_SERIAL_DEBUG(printf_P(PSTR("write_register(%02x)\r\n"), reg));
        }
        beginTransaction();
     780:	a9 cf       	rjmp	.-174    	; 0x6d4 <RF24::csn(bool) [clone .constprop.50]>

00000782 <RF24::write_register(unsigned char, unsigned char, bool) [clone .part.0] [clone .constprop.44]>:
_ZN4RF2414write_registerEhhb.part.0.constprop.44():
     782:	cf 93       	push	r28
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:292
#if defined(RF24_LINUX)
        status = _SPI.transfer(W_REGISTER | reg);
#else // !defined(RF24_LINUX) || defined (RF24_RP2)
    #if defined(RF24_SPI_PTR)
        status = _spi->transfer(W_REGISTER | reg);
     784:	c8 2f       	mov	r28, r24
     786:	c2 df       	rcall	.-124    	; 0x70c <RF24::beginTransaction() [clone .constprop.45]>
     788:	8c 2f       	mov	r24, r28
     78a:	80 62       	ori	r24, 0x20	; 32
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:329
        _SPI.transfer(value);
    #endif // !defined(RF24_SPI_PTR)
        endTransaction();
#endif     // !defined(RF24_LINUX) && !defined(RF24_RP2)
    }
}
     78c:	c2 dc       	rcall	.-1660   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:297
        status = _spi->transfer(W_REGISTER | reg);
    #else  // !defined (RF24_SPI_PTR)
        status = _SPI.transfer(W_REGISTER | reg);
    #endif // !defined (RF24_SPI_PTR)
#endif     // !defined(RF24_LINUX) || defined(RF24_RP2)
        endTransaction();
     78e:	80 93 a5 61 	sts	0x61A5, r24	; 0x8061a5 <radio+0xa>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:281
#endif     // !defined(RF24_LINUX) && !defined(RF24_RP2)
}

/****************************************************************************/

void RF24::write_register(uint8_t reg, uint8_t value, bool is_cmd_only)
     792:	cf 91       	pop	r28
     794:	ab cf       	rjmp	.-170    	; 0x6ec <RF24::endTransaction() [clone .constprop.49]>

00000796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>:
_ZN4RF2414write_registerEhhb.constprop.43():
     796:	cf 93       	push	r28
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:318

        status = *prx++; // status is 1st byte of receive buffer
        endTransaction();
#else // !defined(RF24_LINUX) && !defined(RF24_RP2)

        beginTransaction();
     798:	df 93       	push	r29
     79a:	d8 2f       	mov	r29, r24
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:320
    #if defined(RF24_SPI_PTR)
        status = _spi->transfer(W_REGISTER | reg);
     79c:	c6 2f       	mov	r28, r22
     79e:	b6 df       	rcall	.-148    	; 0x70c <RF24::beginTransaction() [clone .constprop.45]>
     7a0:	8d 2f       	mov	r24, r29
     7a2:	80 62       	ori	r24, 0x20	; 32
     7a4:	b6 dc       	rcall	.-1684   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:321
        _spi->transfer(value);
     7a6:	80 93 a5 61 	sts	0x61A5, r24	; 0x8061a5 <radio+0xa>
     7aa:	8c 2f       	mov	r24, r28
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:329
        _SPI.transfer(value);
    #endif // !defined(RF24_SPI_PTR)
        endTransaction();
#endif     // !defined(RF24_LINUX) && !defined(RF24_RP2)
    }
}
     7ac:	b2 dc       	rcall	.-1692   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
     7ae:	df 91       	pop	r29
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:326
        _spi->transfer(value);
    #else  // !defined(RF24_SPI_PTR)
        status = _SPI.transfer(W_REGISTER | reg);
        _SPI.transfer(value);
    #endif // !defined(RF24_SPI_PTR)
        endTransaction();
     7b0:	cf 91       	pop	r28
     7b2:	9c cf       	rjmp	.-200    	; 0x6ec <RF24::endTransaction() [clone .constprop.49]>

000007b4 <RF24::setPayloadSize(unsigned char) [clone .constprop.29]>:
_ZN4RF2414setPayloadSizeEh.constprop.29():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:621
    return read_register(RF_CH);
}

/****************************************************************************/

void RF24::setPayloadSize(uint8_t size)
     7b4:	cf 93       	push	r28
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:624
{
    // payload size must be in range [1, 32]
    payload_size = static_cast<uint8_t>(rf24_max(1, rf24_min(32, size)));
     7b6:	80 93 a6 61 	sts	0x61A6, r24	; 0x8061a6 <radio+0xb>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:628

    // write static payload size setting for all pipes
    for (uint8_t i = 0; i < 6; ++i) {
        write_register(static_cast<uint8_t>(RX_PW_P0 + i), payload_size);
     7ba:	c1 e1       	ldi	r28, 0x11	; 17
     7bc:	60 91 a6 61 	lds	r22, 0x61A6	; 0x8061a6 <radio+0xb>
     7c0:	8c 2f       	mov	r24, r28
     7c2:	e9 df       	rcall	.-46     	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     7c4:	cf 5f       	subi	r28, 0xFF	; 255
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:627
{
    // payload size must be in range [1, 32]
    payload_size = static_cast<uint8_t>(rf24_max(1, rf24_min(32, size)));

    // write static payload size setting for all pipes
    for (uint8_t i = 0; i < 6; ++i) {
     7c6:	c7 31       	cpi	r28, 0x17	; 23
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:630
        write_register(static_cast<uint8_t>(RX_PW_P0 + i), payload_size);
    }
}
     7c8:	c9 f7       	brne	.-14     	; 0x7bc <RF24::setPayloadSize(unsigned char) [clone .constprop.29]+0x8>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1216

//Power up now. Radio will not power down unless instructed by MCU for config changes etc.
void RF24::powerUp(void)
{
    // if not powered up then power up and wait for the radio to initialize
    if (!(config_reg & _BV(PWR_UP))) {
     7ca:	cf 91       	pop	r28
     7cc:	08 95       	ret

000007ce <RF24::powerUp() [clone .constprop.26]>:
_ZN4RF247powerUpEv.constprop.26():
     7ce:	60 91 ac 61 	lds	r22, 0x61AC	; 0x8061ac <radio+0x11>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1217
        config_reg |= _BV(PWR_UP);
     7d2:	61 fd       	sbrc	r22, 1
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1218
        write_register(NRF_CONFIG, config_reg);
     7d4:	0b c0       	rjmp	.+22     	; 0x7ec <RF24::powerUp() [clone .constprop.26]+0x1e>
     7d6:	62 60       	ori	r22, 0x02	; 2
     7d8:	60 93 ac 61 	sts	0x61AC, r22	; 0x8061ac <radio+0x11>
c:\users\peake\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     7dc:	80 e0       	ldi	r24, 0x00	; 0
     7de:	db df       	rcall	.-74     	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
_delay_us():
     7e0:	8f e2       	ldi	r24, 0x2F	; 47
     7e2:	95 e7       	ldi	r25, 0x75	; 117
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1225
        // For nRF24L01+ to go from power down mode to TX or RX mode it must first pass through stand-by mode.
        // There must be a delay of Tpd2stby (see Table 16.) after the nRF24L01+ leaves power down mode before
        // the CEis set high. - Tpd2stby can be up to 5ms per the 1.0 datasheet
        delayMicroseconds(RF24_POWERUP_DELAY);
    }
}
     7e4:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:196
#endif     // !defined(RF24_LINUX) && !defined(RF24_RP2)
}

/****************************************************************************/

uint8_t RF24::read_register(uint8_t reg)
     7e6:	f1 f7       	brne	.-4      	; 0x7e4 <RF24::powerUp() [clone .constprop.26]+0x16>
     7e8:	00 c0       	rjmp	.+0      	; 0x7ea <RF24::powerUp() [clone .constprop.26]+0x1c>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:220
    result = *++prx; // result is 2nd byte of receive buffer

    endTransaction();
#else // !defined(RF24_LINUX) && !defined(RF24_RP2)

    beginTransaction();
     7ea:	00 00       	nop
_ZN4RF247powerUpEv.constprop.26():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:222
    #if defined(RF24_SPI_PTR)
    status = _spi->transfer(R_REGISTER | reg);
     7ec:	08 95       	ret

000007ee <RF24::read_register(unsigned char) [clone .constprop.42]>:
_ZN4RF2413read_registerEh.constprop.42():
     7ee:	cf 93       	push	r28
     7f0:	c8 2f       	mov	r28, r24
     7f2:	8c df       	rcall	.-232    	; 0x70c <RF24::beginTransaction() [clone .constprop.45]>
     7f4:	8c 2f       	mov	r24, r28
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:223
    result = _spi->transfer(0xff);
     7f6:	8d dc       	rcall	.-1766   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
     7f8:	80 93 a5 61 	sts	0x61A5, r24	; 0x8061a5 <radio+0xa>
     7fc:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:230
    #else // !defined(RF24_SPI_PTR)
    status = _SPI.transfer(R_REGISTER | reg);
    result = _SPI.transfer(0xff);

    #endif // !defined(RF24_SPI_PTR)
    endTransaction();
     7fe:	89 dc       	rcall	.-1774   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:234
#endif     // !defined(RF24_LINUX) && !defined(RF24_RP2)

    return result;
}
     800:	c8 2f       	mov	r28, r24
     802:	74 df       	rcall	.-280    	; 0x6ec <RF24::endTransaction() [clone .constprop.49]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1848
    return (read_register(RPD) & 1);
}

/****************************************************************************/

void RF24::setPALevel(uint8_t level, bool lnaEnable)
     804:	8c 2f       	mov	r24, r28
     806:	cf 91       	pop	r28
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1850
{
    uint8_t setup = read_register(RF_SETUP) & static_cast<uint8_t>(0xF8);
     808:	08 95       	ret

0000080a <RF24::setPALevel(unsigned char, bool) [clone .constprop.41]>:
_ZN4RF2410setPALevelEhb.constprop.41():
     80a:	cf 93       	push	r28
     80c:	c8 2f       	mov	r28, r24
     80e:	86 e0       	ldi	r24, 0x06	; 6
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:2063
uint8_t RF24::_pa_level_reg_value(uint8_t level, bool lnaEnable)
{
    // If invalid level, go to max PA
    // Else set level as requested
    // + lnaEnable (1 or 0) to support the SI24R1 chip extra bit
    return static_cast<uint8_t>(((level > RF24_PA_MAX ? static_cast<uint8_t>(RF24_PA_MAX) : level) << 1) + lnaEnable);
     810:	ee df       	rcall	.-36     	; 0x7ee <RF24::read_register(unsigned char) [clone .constprop.42]>
     812:	88 7f       	andi	r24, 0xF8	; 248
_ZN4RF2419_pa_level_reg_valueEhb():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1851
/****************************************************************************/

void RF24::setPALevel(uint8_t level, bool lnaEnable)
{
    uint8_t setup = read_register(RF_SETUP) & static_cast<uint8_t>(0xF8);
    setup |= _pa_level_reg_value(level, lnaEnable);
     814:	6c 2f       	mov	r22, r28
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1852
    write_register(RF_SETUP, setup);
     816:	66 0f       	add	r22, r22
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1853
}
     818:	6f 5f       	subi	r22, 0xFF	; 255
_ZN4RF2410setPALevelEhb.constprop.41():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1852

void RF24::setPALevel(uint8_t level, bool lnaEnable)
{
    uint8_t setup = read_register(RF_SETUP) & static_cast<uint8_t>(0xF8);
    setup |= _pa_level_reg_value(level, lnaEnable);
    write_register(RF_SETUP, setup);
     81a:	68 2b       	or	r22, r24
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:238
    return result;
}

/****************************************************************************/

void RF24::write_register(uint8_t reg, const uint8_t* buf, uint8_t len)
     81c:	86 e0       	ldi	r24, 0x06	; 6
     81e:	cf 91       	pop	r28
     820:	ba cf       	rjmp	.-140    	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>

00000822 <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.32]>:
_ZN4RF2414write_registerEhPKhh.constprop.32():
     822:	ff 92       	push	r15
     824:	0f 93       	push	r16
     826:	1f 93       	push	r17
     828:	cf 93       	push	r28
     82a:	df 93       	push	r29
     82c:	c8 2f       	mov	r28, r24
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:261

    status = *prx; // status is 1st byte of receive buffer
    endTransaction();
#else // !defined(RF24_LINUX) && !defined(RF24_RP2)

    beginTransaction();
     82e:	f6 2e       	mov	r15, r22
     830:	07 2f       	mov	r16, r23
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:263
    #if defined(RF24_SPI_PTR)
    status = _spi->transfer(W_REGISTER | reg);
     832:	14 2f       	mov	r17, r20
     834:	6b df       	rcall	.-298    	; 0x70c <RF24::beginTransaction() [clone .constprop.45]>
     836:	8c 2f       	mov	r24, r28
     838:	80 62       	ori	r24, 0x20	; 32
     83a:	6b dc       	rcall	.-1834   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
     83c:	80 93 a5 61 	sts	0x61A5, r24	; 0x8061a5 <radio+0xa>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:264
    while (len--) {
     840:	cf 2d       	mov	r28, r15
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:265
        _spi->transfer(*buf++);
     842:	d0 2f       	mov	r29, r16
     844:	11 50       	subi	r17, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:277
    }

    #endif // !defined(RF24_SPI_PTR)
    endTransaction();
#endif     // !defined(RF24_LINUX) && !defined(RF24_RP2)
}
     846:	18 f0       	brcs	.+6      	; 0x84e <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.32]+0x2c>
     848:	89 91       	ld	r24, Y+
     84a:	63 dc       	rcall	.-1850   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:275
    while (len--) {
        _SPI.transfer(*buf++);
    }

    #endif // !defined(RF24_SPI_PTR)
    endTransaction();
     84c:	fb cf       	rjmp	.-10     	; 0x844 <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.32]+0x22>
     84e:	df 91       	pop	r29
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1577
    write_register(TX_ADDR, reinterpret_cast<uint8_t*>(&value), addr_width);
}

/****************************************************************************/

void RF24::openWritingPipe(const uint8_t* address)
     850:	cf 91       	pop	r28
     852:	1f 91       	pop	r17
     854:	0f 91       	pop	r16
     856:	ff 90       	pop	r15
     858:	49 cf       	rjmp	.-366    	; 0x6ec <RF24::endTransaction() [clone .constprop.49]>

0000085a <RF24::openWritingPipe(unsigned char const*) [clone .constprop.31]>:
_ZN4RF2415openWritingPipeEPKh.constprop.31():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1581
{
    // Note that AVR 8-bit uC's store this LSB first, and the NRF24L01(+)
    // expects it LSB first too, so we're good.
    write_register(RX_ADDR_P0, address, addr_width);
     85a:	0f 93       	push	r16
     85c:	1f 93       	push	r17
     85e:	cf 93       	push	r28
     860:	df 93       	push	r29
     862:	ec 01       	movw	r28, r24
     864:	0b e9       	ldi	r16, 0x9B	; 155
     866:	11 e6       	ldi	r17, 0x61	; 97
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1582
    write_register(TX_ADDR, address, addr_width);
     868:	f8 01       	movw	r30, r16
     86a:	45 89       	ldd	r20, Z+21	; 0x15
     86c:	bc 01       	movw	r22, r24
     86e:	8a e0       	ldi	r24, 0x0A	; 10
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1583
}
     870:	d8 df       	rcall	.-80     	; 0x822 <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.32]>
     872:	f8 01       	movw	r30, r16
     874:	45 89       	ldd	r20, Z+21	; 0x15
     876:	be 01       	movw	r22, r28
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1582
void RF24::openWritingPipe(const uint8_t* address)
{
    // Note that AVR 8-bit uC's store this LSB first, and the NRF24L01(+)
    // expects it LSB first too, so we're good.
    write_register(RX_ADDR_P0, address, addr_width);
    write_register(TX_ADDR, address, addr_width);
     878:	80 e1       	ldi	r24, 0x10	; 16
     87a:	df 91       	pop	r29
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1673

/****************************************************************************/

void RF24::toggle_features(void)
{
    beginTransaction();
     87c:	cf 91       	pop	r28
     87e:	1f 91       	pop	r17
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1675
#if defined(RF24_SPI_PTR)
    status = _spi->transfer(ACTIVATE);
     880:	0f 91       	pop	r16
     882:	cf cf       	rjmp	.-98     	; 0x822 <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.32]>

00000884 <RF24::toggle_features() [clone .constprop.15]>:
_ZN4RF2415toggle_featuresEv.constprop.15():
     884:	43 df       	rcall	.-378    	; 0x70c <RF24::beginTransaction() [clone .constprop.45]>
     886:	80 e5       	ldi	r24, 0x50	; 80
     888:	44 dc       	rcall	.-1912   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1676
    _spi->transfer(0x73);
     88a:	80 93 a5 61 	sts	0x61A5, r24	; 0x8061a5 <radio+0xa>
     88e:	83 e7       	ldi	r24, 0x73	; 115
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1681
#else
    status = _SPI.transfer(ACTIVATE);
    _SPI.transfer(0x73);
#endif
    endTransaction();
     890:	40 dc       	rcall	.-1920   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:106
/****************************************************************************/

void RF24::ce(bool level)
{
    //Allow for 3-pin use on ATTiny
    if (ce_pin != csn_pin) {
     892:	2c cf       	rjmp	.-424    	; 0x6ec <RF24::endTransaction() [clone .constprop.49]>

00000894 <RF24::ce(bool) [clone .constprop.40]>:
_ZN4RF242ceEb.constprop.40():
     894:	20 91 9d 61 	lds	r18, 0x619D	; 0x80619d <radio+0x2>
     898:	30 91 9e 61 	lds	r19, 0x619E	; 0x80619e <radio+0x3>
     89c:	40 91 9f 61 	lds	r20, 0x619F	; 0x80619f <radio+0x4>
     8a0:	50 91 a0 61 	lds	r21, 0x61A0	; 0x8061a0 <radio+0x5>
     8a4:	24 17       	cp	r18, r20
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:107
        digitalWrite(ce_pin, level);
     8a6:	35 07       	cpc	r19, r21
     8a8:	19 f0       	breq	.+6      	; 0x8b0 <RF24::ce(bool) [clone .constprop.40]+0x1c>
     8aa:	68 2f       	mov	r22, r24
     8ac:	82 2f       	mov	r24, r18
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1246

#endif
/******************************************************************/

//Similar to the previous write, clears the interrupt flags
bool RF24::write(const void* buf, uint8_t len, const bool multicast)
     8ae:	40 ce       	rjmp	.-896    	; 0x530 <digitalWrite>
     8b0:	08 95       	ret

000008b2 <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]>:
_ZN4RF245writeEPKvhb.constprop.34():
     8b2:	cf 92       	push	r12
     8b4:	df 92       	push	r13
     8b6:	ef 92       	push	r14
     8b8:	ff 92       	push	r15
     8ba:	0f 93       	push	r16
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:338
void RF24::write_payload(const void* buf, uint8_t data_len, const uint8_t writeType)
{
    const uint8_t* current = reinterpret_cast<const uint8_t*>(buf);

    uint8_t blank_len = !data_len ? 1 : 0;
    if (!dynamic_payloads_enabled) {
     8bc:	1f 93       	push	r17
     8be:	cf 93       	push	r28
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:337

void RF24::write_payload(const void* buf, uint8_t data_len, const uint8_t writeType)
{
    const uint8_t* current = reinterpret_cast<const uint8_t*>(buf);

    uint8_t blank_len = !data_len ? 1 : 0;
     8c0:	df 93       	push	r29
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:343
    if (!dynamic_payloads_enabled) {
        data_len = rf24_min(data_len, payload_size);
        blank_len = static_cast<uint8_t>(payload_size - data_len);
    }
    else {
        data_len = rf24_min(data_len, static_cast<uint8_t>(32));
     8c2:	7c 01       	movw	r14, r24
write_payload():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:338
void RF24::write_payload(const void* buf, uint8_t data_len, const uint8_t writeType)
{
    const uint8_t* current = reinterpret_cast<const uint8_t*>(buf);

    uint8_t blank_len = !data_len ? 1 : 0;
    if (!dynamic_payloads_enabled) {
     8c4:	80 91 b1 61 	lds	r24, 0x61B1	; 0x8061b1 <radio+0x16>
_ZN4RF245writeEPKvhb.constprop.34():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:339
        data_len = rf24_min(data_len, payload_size);
     8c8:	c0 e0       	ldi	r28, 0x00	; 0
     8ca:	d8 e0       	ldi	r29, 0x08	; 8
write_payload():
     8cc:	81 11       	cpse	r24, r1
     8ce:	07 c0       	rjmp	.+14     	; 0x8de <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0x2c>
     8d0:	c0 91 a6 61 	lds	r28, 0x61A6	; 0x8061a6 <radio+0xb>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:376
    status = *prx; // status is 1st byte of receive buffer
    endTransaction();

#else // !defined(RF24_LINUX) && !defined(RF24_RP2)

    beginTransaction();
     8d4:	dc 2f       	mov	r29, r28
     8d6:	c9 30       	cpi	r28, 0x09	; 9
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:378
    #if defined(RF24_SPI_PTR)
    status = _spi->transfer(writeType);
     8d8:	08 f0       	brcs	.+2      	; 0x8dc <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0x2a>
     8da:	d8 e0       	ldi	r29, 0x08	; 8
     8dc:	cd 1b       	sub	r28, r29
     8de:	16 df       	rcall	.-468    	; 0x70c <RF24::beginTransaction() [clone .constprop.45]>
     8e0:	80 ea       	ldi	r24, 0xA0	; 160
     8e2:	17 dc       	rcall	.-2002   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:379
    while (data_len--) {
     8e4:	80 93 a5 61 	sts	0x61A5, r24	; 0x8061a5 <radio+0xa>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:380
        _spi->transfer(*current++);
     8e8:	87 01       	movw	r16, r14
     8ea:	d1 50       	subi	r29, 0x01	; 1
     8ec:	28 f0       	brcs	.+10     	; 0x8f8 <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0x46>
     8ee:	f8 01       	movw	r30, r16
     8f0:	81 91       	ld	r24, Z+
     8f2:	8f 01       	movw	r16, r30
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:383
    }

    while (blank_len--) {
     8f4:	0e dc       	rcall	.-2020   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
     8f6:	f9 cf       	rjmp	.-14     	; 0x8ea <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0x38>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:384
        _spi->transfer(0);
     8f8:	c1 50       	subi	r28, 0x01	; 1
     8fa:	18 f0       	brcs	.+6      	; 0x902 <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0x50>
     8fc:	80 e0       	ldi	r24, 0x00	; 0
     8fe:	09 dc       	rcall	.-2030   	; 0x112 <SPIClass::transfer(unsigned char) [clone .constprop.48]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:398
    while (blank_len--) {
        _SPI.transfer(0);
    }

    #endif // !defined(RF24_SPI_PTR)
    endTransaction();
     900:	fb cf       	rjmp	.-10     	; 0x8f8 <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0x46>
     902:	f4 de       	rcall	.-536    	; 0x6ec <RF24::endTransaction() [clone .constprop.49]>
startFastWrite():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1383
void RF24::startFastWrite(const void* buf, uint8_t len, const bool multicast, bool startTx)
{ //TMRh20

    write_payload(buf, len, multicast ? W_TX_PAYLOAD_NO_ACK : W_TX_PAYLOAD);
    if (startTx) {
        ce(HIGH);
     904:	81 e0       	ldi	r24, 0x01	; 1
     906:	c6 df       	rcall	.-116    	; 0x894 <RF24::ce(bool) [clone .constprop.40]>
millis():
     908:	8f b7       	in	r24, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:407
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
     90a:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:408
    cli();
     90c:	c0 90 f7 60 	lds	r12, 0x60F7	; 0x8060f7 <timingStruct>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:459
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
     910:	d0 90 f8 60 	lds	r13, 0x60F8	; 0x8060f8 <timingStruct+0x1>
     914:	e0 90 f9 60 	lds	r14, 0x60F9	; 0x8060f9 <timingStruct+0x2>
     918:	f0 90 fa 60 	lds	r15, 0x60FA	; 0x8060fa <timingStruct+0x3>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:460
      SREG = oldSREG;
     91c:	8f bf       	out	0x3f, r24	; 63
write_register():
     91e:	8f ef       	ldi	r24, 0xFF	; 255
     920:	30 df       	rcall	.-416    	; 0x782 <RF24::write_register(unsigned char, unsigned char, bool) [clone .part.0] [clone .constprop.44]>
_ZN4RF245writeEPKvhb.constprop.34():
     922:	80 91 a5 61 	lds	r24, 0x61A5	; 0x8061a5 <radio+0xa>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1256
//Wait until complete or failed
#if defined(FAILURE_HANDLING) || defined(RF24_LINUX)
    uint32_t timer = millis();
#endif // defined(FAILURE_HANDLING) || defined(RF24_LINUX)

    while (!(get_status() & (_BV(TX_DS) | _BV(MAX_RT)))) {
     926:	80 73       	andi	r24, 0x30	; 48
     928:	09 f5       	brne	.+66     	; 0x96c <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0xba>
millis():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:407
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
     92a:	2f b7       	in	r18, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:408
    cli();
     92c:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:459
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
     92e:	80 91 f7 60 	lds	r24, 0x60F7	; 0x8060f7 <timingStruct>
     932:	90 91 f8 60 	lds	r25, 0x60F8	; 0x8060f8 <timingStruct+0x1>
     936:	a0 91 f9 60 	lds	r26, 0x60F9	; 0x8060f9 <timingStruct+0x2>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:460
      SREG = oldSREG;
     93a:	b0 91 fa 60 	lds	r27, 0x60FA	; 0x8060fa <timingStruct+0x3>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1258
#if defined(FAILURE_HANDLING) || defined(RF24_LINUX)
        if (millis() - timer > 95) {
     93e:	2f bf       	out	0x3f, r18	; 63
_ZN4RF245writeEPKvhb.constprop.34():
     940:	8c 19       	sub	r24, r12
     942:	9d 09       	sbc	r25, r13
     944:	ae 09       	sbc	r26, r14
     946:	bf 09       	sbc	r27, r15
     948:	80 36       	cpi	r24, 0x60	; 96
     94a:	91 05       	cpc	r25, r1
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1236
{
    #if defined(SERIAL_DEBUG) || defined(RF24_LINUX)
    printf_P(PSTR("RF24 HARDWARE FAIL: Radio not responding, verify pin connections, wiring, etc.\r\n"));
    #endif
    #if defined(FAILURE_HANDLING)
    failureDetected = 1;
     94c:	a1 05       	cpc	r26, r1
     94e:	b1 05       	cpc	r27, r1
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1276
    write_register(NRF_STATUS, _BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT));

    //Max retries exceeded
    if (status & _BV(MAX_RT)) {
        flush_tx(); // Only going to be 1 packet in the FIFO at a time using this method, so just flush
        return 0;
     950:	30 f3       	brcs	.-52     	; 0x91e <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0x6c>
errNotify():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1280
    }
    //TX OK 1 or 0
    return 1;
}
     952:	81 e0       	ldi	r24, 0x01	; 1
     954:	80 93 b2 61 	sts	0x61B2, r24	; 0x8061b2 <radio+0x17>
_ZN4RF245writeEPKvhb.constprop.34():
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	df 91       	pop	r29
     95c:	cf 91       	pop	r28
     95e:	1f 91       	pop	r17
     960:	0f 91       	pop	r16
     962:	ff 90       	pop	r15
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1269
    #endif
        }
#endif
    }

    ce(LOW);
     964:	ef 90       	pop	r14
     966:	df 90       	pop	r13
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1271

    write_register(NRF_STATUS, _BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT));
     968:	cf 90       	pop	r12
     96a:	08 95       	ret
     96c:	80 e0       	ldi	r24, 0x00	; 0
     96e:	92 df       	rcall	.-220    	; 0x894 <RF24::ce(bool) [clone .constprop.40]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1274

    //Max retries exceeded
    if (status & _BV(MAX_RT)) {
     970:	60 e7       	ldi	r22, 0x70	; 112
     972:	87 e0       	ldi	r24, 0x07	; 7
     974:	10 df       	rcall	.-480    	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     976:	80 91 a5 61 	lds	r24, 0x61A5	; 0x8061a5 <radio+0xa>
     97a:	84 ff       	sbrs	r24, 4
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1279
        flush_tx(); // Only going to be 1 packet in the FIFO at a time using this method, so just flush
        return 0;
    }
    //TX OK 1 or 0
    return 1;
     97c:	03 c0       	rjmp	.+6      	; 0x984 <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0xd2>
write_register():
     97e:	81 ee       	ldi	r24, 0xE1	; 225
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1180
static const PROGMEM uint8_t child_pipe_enable[] = {ERX_P0, ERX_P1, ERX_P2,
                                                    ERX_P3, ERX_P4, ERX_P5};

void RF24::stopListening(void)
{
    ce(LOW);
     980:	00 df       	rcall	.-512    	; 0x782 <RF24::write_register(unsigned char, unsigned char, bool) [clone .part.0] [clone .constprop.44]>
     982:	ea cf       	rjmp	.-44     	; 0x958 <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0xa6>
_ZN4RF245writeEPKvhb.constprop.34():
     984:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:981
inline __attribute__((always_inline)) void delayMicroseconds(unsigned int us) {
  // This function gets optimized away, but to what depends on whether us is constant.
  if (__builtin_constant_p(us)) {
    _delay_us(us); // Constant microseconds use the avr-libc _delay_us() which is highly accurate for all values and efficient!
  } else { // If it is not, we have to use the Arduino style implementation.
    _delayMicroseconds(us);
     986:	e9 cf       	rjmp	.-46     	; 0x95a <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]+0xa8>

00000988 <RF24::stopListening() [clone .constprop.30]>:
_ZN4RF2413stopListeningEv.constprop.30():
     988:	80 e0       	ldi	r24, 0x00	; 0
     98a:	84 df       	rcall	.-248    	; 0x894 <RF24::ce(bool) [clone .constprop.40]>
delayMicroseconds():
     98c:	80 91 b3 61 	lds	r24, 0x61B3	; 0x8061b3 <radio+0x18>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1184

    //delayMicroseconds(100);
    delayMicroseconds(static_cast<int>(txDelay));
    if (ack_payloads_enabled) {
     990:	90 91 b4 61 	lds	r25, 0x61B4	; 0x8061b4 <radio+0x19>
     994:	e4 dc       	rcall	.-1592   	; 0x35e <_delayMicroseconds>
_ZN4RF2413stopListeningEv.constprop.30():
     996:	80 91 af 61 	lds	r24, 0x61AF	; 0x8061af <radio+0x14>
     99a:	88 23       	and	r24, r24
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1188
        flush_tx();
    }

    config_reg = static_cast<uint8_t>(config_reg & ~_BV(PRIM_RX));
     99c:	11 f0       	breq	.+4      	; 0x9a2 <RF24::stopListening() [clone .constprop.30]+0x1a>
write_register():
     99e:	81 ee       	ldi	r24, 0xE1	; 225
     9a0:	f0 de       	rcall	.-544    	; 0x782 <RF24::write_register(unsigned char, unsigned char, bool) [clone .part.0] [clone .constprop.44]>
_ZN4RF2413stopListeningEv.constprop.30():
     9a2:	60 91 ac 61 	lds	r22, 0x61AC	; 0x8061ac <radio+0x11>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1189
    write_register(NRF_CONFIG, config_reg);
     9a6:	6e 7f       	andi	r22, 0xFE	; 254
     9a8:	60 93 ac 61 	sts	0x61AC, r22	; 0x8061ac <radio+0x11>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1198
    if (ce_pin == csn_pin) {
        powerDown();
        powerUp();
    }
#endif
    write_register(EN_RXADDR, static_cast<uint8_t>(read_register(EN_RXADDR) | _BV(pgm_read_byte(&child_pipe_enable[0])))); // Enable RX on pipe0
     9ac:	80 e0       	ldi	r24, 0x00	; 0
     9ae:	f3 de       	rcall	.-538    	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     9b0:	82 e0       	ldi	r24, 0x02	; 2
     9b2:	1d df       	rcall	.-454    	; 0x7ee <RF24::read_register(unsigned char) [clone .constprop.42]>
     9b4:	e0 e9       	ldi	r30, 0x90	; 144
     9b6:	f0 e0       	ldi	r31, 0x00	; 0
     9b8:	e4 91       	lpm	r30, Z
     9ba:	61 e0       	ldi	r22, 0x01	; 1
     9bc:	70 e0       	ldi	r23, 0x00	; 0
     9be:	01 c0       	rjmp	.+2      	; 0x9c2 <RF24::stopListening() [clone .constprop.30]+0x3a>
     9c0:	66 0f       	add	r22, r22
     9c2:	ea 95       	dec	r30
     9c4:	ea f7       	brpl	.-6      	; 0x9c0 <RF24::stopListening() [clone .constprop.30]+0x38>
     9c6:	68 2b       	or	r22, r24
     9c8:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1157
/****************************************************************************/

void RF24::startListening(void)
{
#if !defined(RF24_TINY) && !defined(LITTLEWIRE)
    powerUp();
     9ca:	e5 ce       	rjmp	.-566    	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>

000009cc <RF24::startListening() [clone .constprop.25]>:
_ZN4RF2414startListeningEv.constprop.25():
     9cc:	00 df       	rcall	.-512    	; 0x7ce <RF24::powerUp() [clone .constprop.26]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1159
#endif
    config_reg |= _BV(PRIM_RX);
     9ce:	60 91 ac 61 	lds	r22, 0x61AC	; 0x8061ac <radio+0x11>
     9d2:	61 60       	ori	r22, 0x01	; 1
     9d4:	60 93 ac 61 	sts	0x61AC, r22	; 0x8061ac <radio+0x11>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1160
    write_register(NRF_CONFIG, config_reg);
     9d8:	80 e0       	ldi	r24, 0x00	; 0
     9da:	dd de       	rcall	.-582    	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     9dc:	60 e7       	ldi	r22, 0x70	; 112
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1161
    write_register(NRF_STATUS, _BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT));
     9de:	87 e0       	ldi	r24, 0x07	; 7
     9e0:	da de       	rcall	.-588    	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	57 df       	rcall	.-338    	; 0x894 <RF24::ce(bool) [clone .constprop.40]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1162
    ce(HIGH);
     9e6:	80 91 ae 61 	lds	r24, 0x61AE	; 0x8061ae <radio+0x13>
     9ea:	88 23       	and	r24, r24
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1165

    // Restore the pipe0 address, if exists
    if (_is_p0_rx) {
     9ec:	31 f0       	breq	.+12     	; 0x9fa <RF24::startListening() [clone .constprop.25]+0x2e>
     9ee:	40 91 b0 61 	lds	r20, 0x61B0	; 0x8061b0 <radio+0x15>
     9f2:	67 ea       	ldi	r22, 0xA7	; 167
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1166
        write_register(RX_ADDR_P0, pipe0_reading_address, addr_width);
     9f4:	71 e6       	ldi	r23, 0x61	; 97
     9f6:	8a e0       	ldi	r24, 0x0A	; 10
     9f8:	14 cf       	rjmp	.-472    	; 0x822 <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.32]>
closeReadingPipe():
     9fa:	82 e0       	ldi	r24, 0x02	; 2
     9fc:	f8 de       	rcall	.-528    	; 0x7ee <RF24::read_register(unsigned char) [clone .constprop.42]>
     9fe:	e0 e9       	ldi	r30, 0x90	; 144
     a00:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1662

/****************************************************************************/

void RF24::closeReadingPipe(uint8_t pipe)
{
    write_register(EN_RXADDR, static_cast<uint8_t>(read_register(EN_RXADDR) & ~_BV(pgm_read_byte(&child_pipe_enable[pipe]))));
     a02:	e4 91       	lpm	r30, Z
     a04:	21 e0       	ldi	r18, 0x01	; 1
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	01 c0       	rjmp	.+2      	; 0xa0c <RF24::startListening() [clone .constprop.25]+0x40>
     a0a:	22 0f       	add	r18, r18
     a0c:	ea 95       	dec	r30
     a0e:	ea f7       	brpl	.-6      	; 0xa0a <RF24::startListening() [clone .constprop.25]+0x3e>
     a10:	20 95       	com	r18
     a12:	62 2f       	mov	r22, r18
     a14:	68 23       	and	r22, r24
     a16:	82 e0       	ldi	r24, 0x02	; 2
     a18:	be de       	rcall	.-644    	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     a1a:	10 92 ae 61 	sts	0x61AE, r1	; 0x8061ae <radio+0x13>
_ZN4RF2414startListeningEv.constprop.25():
     a1e:	08 95       	ret

00000a20 <nrf_setup()>:
_Z9nrf_setupv():
     a20:	cf 93       	push	r28
     a22:	df 93       	push	r29
begin():
     a24:	e0 91 9b 61 	lds	r30, 0x619B	; 0x80619b <radio>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1665
    if (!pipe) {
        // keep track of pipe 0's RX state to avoid null vs 0 in addr cache
        _is_p0_rx = false;
     a28:	f0 91 9c 61 	lds	r31, 0x619C	; 0x80619c <radio+0x1>
init():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:246
  for (int i = 0; i < 4; i++) attachInterrupt(digitalPinToInterrupt(row_input_pin[i]), button_press_ISR, FALLING);
  attachInterrupt(digitalPinToInterrupt(BTN_CANCEL), button_press_ISR, FALLING);
}

// Radio Tx setup
bool nrf_setup(void) {
     a2c:	87 81       	ldd	r24, Z+7	; 0x07
     a2e:	81 11       	cpse	r24, r1
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1007
    _spi->begin(PICO_DEFAULT_SPI ? spi1 : spi0);

#else // using an Arduino platform || defined (LITTLEWIRE)

    #if defined(RF24_SPI_PTR)
    _spi->begin();
     a30:	06 c0       	rjmp	.+12     	; 0xa3e <nrf_setup()+0x1e>
     a32:	10 86       	std	Z+8, r1	; 0x08
     a34:	12 86       	std	Z+10, r1	; 0x0a
     a36:	80 e8       	ldi	r24, 0x80	; 128
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:370
  // We don't call this now because we are about to call config which does the same thing.
  config(DEFAULT_SPI_SETTINGS);
}

void SPIClass::init() {
  if (initialized)
     a38:	81 87       	std	Z+9, r24	; 0x09
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	87 83       	std	Z+7, r24	; 0x07
begin():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:372
    return;
  interruptMode = SPI_IMODE_NONE;
     a3e:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7f05e5>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:379
  interruptSave = 0;
  interruptMask_lo = 0;
  interruptMask_hi = 0;
  #else
  in_transaction = 0;
  old_sreg = 0x80;
     a42:	88 7f       	andi	r24, 0xF8	; 248
     a44:	96 81       	ldd	r25, Z+6	; 0x06
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:381
  #endif
  initialized = true;
     a46:	89 2b       	or	r24, r25
     a48:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7f05e5>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:339
  #if !defined(SPI1)
    // Implementation for tinyAVR 0/1/2-series, megaAVR 0-series and AVR DD-series, which only have a single SPI interface.
    // First, configure PORTMUX.
    #if defined(PORTMUX_SPIROUTEA)
      // AVR DD-series, tinyAVR 2-series
      PORTMUX.SPIROUTEA = _uc_mux | (PORTMUX.SPIROUTEA & ~PORTMUX_SPI0_gm);
     a4c:	84 81       	ldd	r24, Z+4	; 0x04
_pinMode():
     a4e:	8c 31       	cpi	r24, 0x1C	; 28
     a50:	90 f4       	brcc	.+36     	; 0xa76 <nrf_setup()+0x56>
check_valid_digital_pin():
     a52:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
     a54:	dc 01       	movw	r26, r24
     a56:	af 5c       	subi	r26, 0xCF	; 207
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:361
      // we're set to use SPI1
      PORTMUX.SPIROUTEA = _uc_mux | (PORTMUX.SPIROUTEA & (~PORTMUX_SPI1_gm));
    }
  #endif
  // no matter what we had to do about the mux; MOSI and SCK need to be set output - but now we set that up already instead of doing it here.
  pinMode(_uc_pinSCK,  OUTPUT);
     a58:	bf 49       	sbci	r27, 0x9F	; 159
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     a5a:	2c 91       	ld	r18, X
     a5c:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/Arduino.h:800
     a5e:	59 f0       	breq	.+22     	; 0xa76 <nrf_setup()+0x56>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
     a60:	83 5a       	subi	r24, 0xA3	; 163
     a62:	9f 49       	sbci	r25, 0x9F	; 159
     a64:	ec 01       	movw	r28, r24
     a66:	a8 81       	ld	r26, Y
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     a68:	d0 e2       	ldi	r29, 0x20	; 32
     a6a:	ad 9f       	mul	r26, r29
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     a6c:	d0 01       	movw	r26, r0
     a6e:	11 24       	eor	r1, r1
     a70:	bc 5f       	subi	r27, 0xFC	; 252
     a72:	11 96       	adiw	r26, 0x01	; 1
     a74:	2c 93       	st	X, r18
begin():
     a76:	83 81       	ldd	r24, Z+3	; 0x03
_pinMode():
     a78:	8c 31       	cpi	r24, 0x1C	; 28
     a7a:	88 f4       	brcc	.+34     	; 0xa9e <nrf_setup()+0x7e>
check_valid_digital_pin():
     a7c:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
     a7e:	fc 01       	movw	r30, r24
     a80:	ef 5c       	subi	r30, 0xCF	; 207
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:362
  pinMode(_uc_pinMOSI, OUTPUT);
     a82:	ff 49       	sbci	r31, 0x9F	; 159
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     a84:	20 81       	ld	r18, Z
     a86:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/Arduino.h:800
     a88:	51 f0       	breq	.+20     	; 0xa9e <nrf_setup()+0x7e>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
     a8a:	83 5a       	subi	r24, 0xA3	; 163
     a8c:	9f 49       	sbci	r25, 0x9F	; 159
     a8e:	dc 01       	movw	r26, r24
     a90:	ec 91       	ld	r30, X
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     a92:	b0 e2       	ldi	r27, 0x20	; 32
     a94:	eb 9f       	mul	r30, r27
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     a96:	f0 01       	movw	r30, r0
     a98:	11 24       	eor	r1, r1
     a9a:	fc 5f       	subi	r31, 0xFC	; 252
     a9c:	21 83       	std	Z+1, r18	; 0x01
     a9e:	90 91 8e 61 	lds	r25, 0x618E	; 0x80618e <DEFAULT_SPI_SETTINGS>
     aa2:	80 91 8f 61 	lds	r24, 0x618F	; 0x80618f <DEFAULT_SPI_SETTINGS+0x1>
config():
     aa6:	90 93 40 09 	sts	0x0940, r25	; 0x800940 <__TEXT_REGION_LENGTH__+0x7f0940>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
     aaa:	80 93 41 09 	sts	0x0941, r24	; 0x800941 <__TEXT_REGION_LENGTH__+0x7f0941>
isValid():
     aae:	80 91 9d 61 	lds	r24, 0x619D	; 0x80619d <radio+0x2>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:385
  #endif
  initialized = true;
}

void SPIClass::config(SPISettings settings) {
  SPI_MODULE.CTRLA = settings.ctrla;
     ab2:	90 91 9e 61 	lds	r25, 0x619E	; 0x80619e <radio+0x3>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\libraries\SPI\src/SPI.cpp:386
  SPI_MODULE.CTRLB = settings.ctrlb;
     ab6:	8f 3f       	cpi	r24, 0xFF	; 255
     ab8:	98 07       	cpc	r25, r24
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1149

/****************************************************************************/

bool RF24::isValid()
{
    return ce_pin != 0xFFFF && csn_pin != 0xFFFF;
     aba:	21 f4       	brne	.+8      	; 0xac4 <nrf_setup()+0xa4>
_Z9nrf_setupv():
     abc:	80 e0       	ldi	r24, 0x00	; 0
     abe:	df 91       	pop	r29
     ac0:	cf 91       	pop	r28
     ac2:	08 95       	ret
isValid():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:249
  if (!radio.begin()) {
    if (debug) SerialDebug.println("NRF24L01 radio hardware is not responding");
    return false;
     ac4:	20 91 9f 61 	lds	r18, 0x619F	; 0x80619f <radio+0x4>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:258
  radio.setPALevel(RF24_PA_HIGH);  // RF24_PA_MAX is default.
  radio.stopListening();
  radio.openWritingPipe(tx_pipe_uid);

  return true;
}
     ac8:	30 91 a0 61 	lds	r19, 0x61A0	; 0x8061a0 <radio+0x5>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1149
     acc:	2f 3f       	cpi	r18, 0xFF	; 255
     ace:	32 07       	cpc	r19, r18
     ad0:	a9 f3       	breq	.-22     	; 0xabc <nrf_setup()+0x9c>
_init_pins():
     ad2:	82 17       	cp	r24, r18
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1052
    delay(200);

#else // using an Arduino platform

    // Initialize pins
    if (ce_pin != csn_pin) {
     ad4:	93 07       	cpc	r25, r19
     ad6:	51 f1       	breq	.+84     	; 0xb2c <nrf_setup()+0x10c>
_pinMode():
     ad8:	8c 31       	cpi	r24, 0x1C	; 28
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     ada:	88 f4       	brcc	.+34     	; 0xafe <nrf_setup()+0xde>
check_valid_digital_pin():
     adc:	99 27       	eor	r25, r25
_pinMode():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/Arduino.h:800
     ade:	fc 01       	movw	r30, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
     ae0:	ef 5c       	subi	r30, 0xCF	; 207
     ae2:	ff 49       	sbci	r31, 0x9F	; 159
     ae4:	20 81       	ld	r18, Z
     ae6:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     ae8:	51 f0       	breq	.+20     	; 0xafe <nrf_setup()+0xde>
     aea:	83 5a       	subi	r24, 0xA3	; 163
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     aec:	9f 49       	sbci	r25, 0x9F	; 159
     aee:	dc 01       	movw	r26, r24
     af0:	ec 91       	ld	r30, X
     af2:	b0 e2       	ldi	r27, 0x20	; 32
     af4:	eb 9f       	mul	r30, r27
     af6:	f0 01       	movw	r30, r0
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
     af8:	11 24       	eor	r1, r1
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1054
        pinMode(ce_pin, OUTPUT);
        pinMode(csn_pin, OUTPUT);
     afa:	fc 5f       	subi	r31, 0xFC	; 252
     afc:	21 83       	std	Z+1, r18	; 0x01
_init_pins():
     afe:	80 91 9f 61 	lds	r24, 0x619F	; 0x80619f <radio+0x4>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     b02:	90 91 a0 61 	lds	r25, 0x61A0	; 0x8061a0 <radio+0x5>
_pinMode():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/Arduino.h:800
     b06:	8c 31       	cpi	r24, 0x1C	; 28
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
     b08:	88 f4       	brcc	.+34     	; 0xb2c <nrf_setup()+0x10c>
check_valid_digital_pin():
     b0a:	99 27       	eor	r25, r25
_pinMode():
     b0c:	fc 01       	movw	r30, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     b0e:	ef 5c       	subi	r30, 0xCF	; 207
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     b10:	ff 49       	sbci	r31, 0x9F	; 159
     b12:	20 81       	ld	r18, Z
     b14:	2f 3f       	cpi	r18, 0xFF	; 255
     b16:	51 f0       	breq	.+20     	; 0xb2c <nrf_setup()+0x10c>
     b18:	83 5a       	subi	r24, 0xA3	; 163
     b1a:	9f 49       	sbci	r25, 0x9F	; 159
     b1c:	ec 01       	movw	r28, r24
     b1e:	e8 81       	ld	r30, Y
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
     b20:	d0 e2       	ldi	r29, 0x20	; 32
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1057
    }

    ce(LOW);
     b22:	ed 9f       	mul	r30, r29
     b24:	f0 01       	movw	r30, r0
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1058
    csn(HIGH);
     b26:	11 24       	eor	r1, r1
     b28:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1078
    // This is actually only required following power up but some settling time also appears to
    // be required after resets too. For full coverage, we'll always assume the worst.
    // Enabling 16b CRC is by far the most obvious case if the wrong timing is used - or skipped.
    // Technically we require 4.5ms + 14us as a worst case. We'll just call it 5ms for good measure.
    // WARNING: Delay is based on P-variant whereby non-P *may* require different timing.
    delay(5);
     b2a:	21 83       	std	Z+1, r18	; 0x01
_init_pins():
     b2c:	80 e0       	ldi	r24, 0x00	; 0
     b2e:	b2 de       	rcall	.-668    	; 0x894 <RF24::ce(bool) [clone .constprop.40]>
     b30:	81 e0       	ldi	r24, 0x01	; 1
     b32:	d0 dd       	rcall	.-1120   	; 0x6d4 <RF24::csn(bool) [clone .constprop.50]>
_init_radio():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1964
}

/****************************************************************************/
void RF24::setRetries(uint8_t delay, uint8_t count)
{
    write_register(SETUP_RETR, static_cast<uint8_t>(rf24_min(15, delay) << ARD | rf24_min(15, count)));
     b34:	65 e0       	ldi	r22, 0x05	; 5
     b36:	70 e0       	ldi	r23, 0x00	; 0
     b38:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1874
/****************************************************************************/

bool RF24::setDataRate(rf24_datarate_e speed)
{
    bool result = false;
    uint8_t setup = read_register(RF_SETUP);
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	66 dc       	rcall	.-1844   	; 0x40a <delay>
setRetries():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:2028
/****************************************************************************/

uint8_t RF24::_data_rate_reg_value(rf24_datarate_e speed)
{
#if !defined(F_CPU) || F_CPU > 20000000
    txDelay = 280;
     b3e:	6f e5       	ldi	r22, 0x5F	; 95
     b40:	84 e0       	ldi	r24, 0x04	; 4
     b42:	29 de       	rcall	.-942    	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
setDataRate():
     b44:	86 e0       	ldi	r24, 0x06	; 6
     b46:	53 de       	rcall	.-858    	; 0x7ee <RF24::read_register(unsigned char) [clone .constprop.42]>
_ZN4RF2420_data_rate_reg_valueE15rf24_datarate_e.isra.15():
     b48:	48 e1       	ldi	r20, 0x18	; 24
     b4a:	51 e0       	ldi	r21, 0x01	; 1
     b4c:	60 e0       	ldi	r22, 0x00	; 0
     b4e:	70 e0       	ldi	r23, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1877
{
    bool result = false;
    uint8_t setup = read_register(RF_SETUP);

    // HIGH and LOW '00' is 1Mbs - our default
    setup = static_cast<uint8_t>(setup & ~(_BV(RF_DR_LOW) | _BV(RF_DR_HIGH)));
     b50:	40 93 b3 61 	sts	0x61B3, r20	; 0x8061b3 <radio+0x18>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1880
    setup |= _data_rate_reg_value(speed);

    write_register(RF_SETUP, setup);
     b54:	50 93 b4 61 	sts	0x61B4, r21	; 0x8061b4 <radio+0x19>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1883

    // Verify our result
    if (read_register(RF_SETUP) == setup) {
     b58:	60 93 b5 61 	sts	0x61B5, r22	; 0x8061b5 <radio+0x1a>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1089

    // Then set the data rate to the slowest (and most reliable) speed supported by all hardware.
    setDataRate(RF24_1MBPS);

    // detect if is a plus variant & use old toggle features command accordingly
    uint8_t before_toggle = read_register(FEATURE);
     b5c:	70 93 b6 61 	sts	0x61B6, r23	; 0x8061b6 <radio+0x1b>
setDataRate():
     b60:	68 2f       	mov	r22, r24
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1090
    toggle_features();
     b62:	67 7d       	andi	r22, 0xD7	; 215
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1091
    uint8_t after_toggle = read_register(FEATURE);
     b64:	86 e0       	ldi	r24, 0x06	; 6
     b66:	17 de       	rcall	.-978    	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     b68:	86 e0       	ldi	r24, 0x06	; 6
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1092
    _is_p_variant = before_toggle == after_toggle;
     b6a:	41 de       	rcall	.-894    	; 0x7ee <RF24::read_register(unsigned char) [clone .constprop.42]>
_init_radio():
     b6c:	8d e1       	ldi	r24, 0x1D	; 29
     b6e:	3f de       	rcall	.-898    	; 0x7ee <RF24::read_register(unsigned char) [clone .constprop.42]>
     b70:	c8 2f       	mov	r28, r24
     b72:	88 de       	rcall	.-752    	; 0x884 <RF24::toggle_features() [clone .constprop.15]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1093
    if (after_toggle) {
     b74:	8d e1       	ldi	r24, 0x1D	; 29
     b76:	3b de       	rcall	.-906    	; 0x7ee <RF24::read_register(unsigned char) [clone .constprop.42]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1094
        if (_is_p_variant) {
     b78:	91 e0       	ldi	r25, 0x01	; 1
     b7a:	c8 13       	cpse	r28, r24
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1096
            // module did not experience power-on-reset (#401)
            toggle_features();
     b7c:	90 e0       	ldi	r25, 0x00	; 0
     b7e:	90 93 ad 61 	sts	0x61AD, r25	; 0x8061ad <radio+0x12>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1099
        }
        // allow use of multicast parameter and dynamic payloads by default
        write_register(FEATURE, 0);
     b82:	88 23       	and	r24, r24
     b84:	31 f0       	breq	.+12     	; 0xb92 <nrf_setup()+0x172>
     b86:	c8 13       	cpse	r28, r24
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1101
    }
    ack_payloads_enabled = false; // ack payloads disabled by default
     b88:	01 c0       	rjmp	.+2      	; 0xb8c <nrf_setup()+0x16c>
     b8a:	7c de       	rcall	.-776    	; 0x884 <RF24::toggle_features() [clone .constprop.15]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1102
    write_register(DYNPD, 0);     // disable dynamic payloads by default (for all pipes)
     b8c:	60 e0       	ldi	r22, 0x00	; 0
     b8e:	8d e1       	ldi	r24, 0x1D	; 29
     b90:	02 de       	rcall	.-1020   	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1103
    dynamic_payloads_enabled = false;
     b92:	10 92 af 61 	sts	0x61AF, r1	; 0x8061af <radio+0x14>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1104
    write_register(EN_AA, 0x3F);  // enable auto-ack on all pipes
     b96:	60 e0       	ldi	r22, 0x00	; 0
     b98:	8c e1       	ldi	r24, 0x1C	; 28
     b9a:	fd dd       	rcall	.-1030   	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     b9c:	10 92 b1 61 	sts	0x61B1, r1	; 0x8061b1 <radio+0x16>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1105
    write_register(EN_RXADDR, 3); // only open RX pipes 0 & 1
     ba0:	6f e3       	ldi	r22, 0x3F	; 63
     ba2:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1106
    setPayloadSize(32);           // set static payload size to 32 (max) bytes by default
     ba4:	f8 dd       	rcall	.-1040   	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     ba6:	63 e0       	ldi	r22, 0x03	; 3
     ba8:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1622

void RF24::setAddressWidth(uint8_t a_width)
{
    a_width = static_cast<uint8_t>(a_width - 2);
    if (a_width) {
        write_register(SETUP_AW, static_cast<uint8_t>(a_width % 4));
     baa:	f5 dd       	rcall	.-1046   	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     bac:	80 e2       	ldi	r24, 0x20	; 32
     bae:	02 de       	rcall	.-1020   	; 0x7b4 <RF24::setPayloadSize(unsigned char) [clone .constprop.29]>
setAddressWidth():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1623
        addr_width = static_cast<uint8_t>((a_width % 4) + 2);
     bb0:	63 e0       	ldi	r22, 0x03	; 3
     bb2:	83 e0       	ldi	r24, 0x03	; 3
     bb4:	f0 dd       	rcall	.-1056   	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:611
/****************************************************************************/

void RF24::setChannel(uint8_t channel)
{
    const uint8_t max_channel = 125;
    write_register(RF_CH, rf24_min(channel, max_channel));
     bb6:	85 e0       	ldi	r24, 0x05	; 5
     bb8:	80 93 b0 61 	sts	0x61B0, r24	; 0x8061b0 <radio+0x15>
setChannel():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1116
    // spectrum.
    setChannel(76);

    // Reset current status
    // Notice reset and flush is the last thing we do
    write_register(NRF_STATUS, _BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT));
     bbc:	6c e4       	ldi	r22, 0x4C	; 76
     bbe:	eb dd       	rcall	.-1066   	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
_init_radio():
     bc0:	60 e7       	ldi	r22, 0x70	; 112
     bc2:	87 e0       	ldi	r24, 0x07	; 7
     bc4:	e8 dd       	rcall	.-1072   	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
write_register():
     bc6:	82 ee       	ldi	r24, 0xE2	; 226
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1129
    //      Enable PTX
    //      Power Up
    //      16-bit CRC (CRC required by auto-ack)
    // Do not write CE high so radio will remain in standby I mode
    // PTX should use only 22uA of power
    write_register(NRF_CONFIG, (_BV(EN_CRC) | _BV(CRCO)));
     bc8:	dc dd       	rcall	.-1096   	; 0x782 <RF24::write_register(unsigned char, unsigned char, bool) [clone .part.0] [clone .constprop.44]>
     bca:	81 ee       	ldi	r24, 0xE1	; 225
     bcc:	da dd       	rcall	.-1100   	; 0x782 <RF24::write_register(unsigned char, unsigned char, bool) [clone .part.0] [clone .constprop.44]>
_init_radio():
     bce:	6c e0       	ldi	r22, 0x0C	; 12
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1130
    config_reg = read_register(NRF_CONFIG);
     bd0:	80 e0       	ldi	r24, 0x00	; 0
     bd2:	e1 dd       	rcall	.-1086   	; 0x796 <RF24::write_register(unsigned char, unsigned char, bool) [clone .constprop.43]>
     bd4:	80 e0       	ldi	r24, 0x00	; 0
     bd6:	0b de       	rcall	.-1002   	; 0x7ee <RF24::read_register(unsigned char) [clone .constprop.42]>
     bd8:	80 93 ac 61 	sts	0x61AC, r24	; 0x8061ac <radio+0x11>
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1132

    powerUp();
     bdc:	f8 dd       	rcall	.-1040   	; 0x7ce <RF24::powerUp() [clone .constprop.26]>
begin():
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1014
    _SPI.begin();
    #endif // !defined(RF24_SPI_PTR)

#endif // !defined(XMEGA_D3) && !defined(RF24_LINUX)

    return _init_pins() && _init_radio();
     bde:	80 91 ac 61 	lds	r24, 0x61AC	; 0x8061ac <radio+0x11>
     be2:	8e 30       	cpi	r24, 0x0E	; 14
     be4:	09 f0       	breq	.+2      	; 0xbe8 <nrf_setup()+0x1c8>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:252
  if (!radio.begin()) {
    if (debug) SerialDebug.println("NRF24L01 radio hardware is not responding");
    return false;
  }
  if (debug) SerialDebug.println("NRF24L01 initialised OK");
  radio.setPayloadSize(8);
     be6:	6a cf       	rjmp	.-300    	; 0xabc <nrf_setup()+0x9c>
_Z9nrf_setupv():
     be8:	88 e0       	ldi	r24, 0x08	; 8
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:253
  radio.setPALevel(RF24_PA_HIGH);  // RF24_PA_MAX is default.
     bea:	e4 dd       	rcall	.-1080   	; 0x7b4 <RF24::setPayloadSize(unsigned char) [clone .constprop.29]>
     bec:	82 e0       	ldi	r24, 0x02	; 2
     bee:	0d de       	rcall	.-998    	; 0x80a <RF24::setPALevel(unsigned char, bool) [clone .constprop.41]>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:254
  radio.stopListening();
     bf0:	cb de       	rcall	.-618    	; 0x988 <RF24::stopListening() [clone .constprop.30]>
     bf2:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:255
  radio.openWritingPipe(tx_pipe_uid);
     bf4:	90 e6       	ldi	r25, 0x60	; 96
     bf6:	31 de       	rcall	.-926    	; 0x85a <RF24::openWritingPipe(unsigned char const*) [clone .constprop.31]>
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	61 cf       	rjmp	.-318    	; 0xabe <nrf_setup()+0x9e>

00000bfc <system_sleep()>:
_Z12system_sleepv():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:257

  return true;
     bfc:	61 e0       	ldi	r22, 0x01	; 1
     bfe:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:110
}

//---------------------------Main Functions----------------------------//

void system_sleep(void) {
  digitalWrite(NRF_PS_EN, HIGH);
     c00:	97 dc       	rcall	.-1746   	; 0x530 <digitalWrite>
     c02:	e0 e0       	ldi	r30, 0x00	; 0
     c04:	f6 e0       	ldi	r31, 0x06	; 6
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:111
  ADC0.CTRLA &= ~ADC_ENABLE_bm;
     c06:	80 81       	ld	r24, Z
     c08:	8e 7f       	andi	r24, 0xFE	; 254
     c0a:	80 83       	st	Z, r24
     c0c:	88 95       	sleep
     c0e:	08 95       	ret

00000c10 <button_press_ISR()>:
_Z16button_press_ISRv():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:112
  sleep_cpu();
     c10:	bf 92       	push	r11
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:113
}
     c12:	cf 92       	push	r12
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:80
//------------------------------Functions-----------------------------//
//********************************************************************//

//---------------------------ISR Functions----------------------------//

void button_press_ISR(void) {
     c14:	df 92       	push	r13
     c16:	ef 92       	push	r14
     c18:	ff 92       	push	r15
     c1a:	0f 93       	push	r16
     c1c:	1f 93       	push	r17
     c1e:	cf 93       	push	r28
     c20:	df 93       	push	r29
     c22:	80 91 f0 60 	lds	r24, 0x60F0	; 0x8060f0 <pairing>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:81
  if (pairing) {
     c26:	81 11       	cpse	r24, r1
     c28:	6a c0       	rjmp	.+212    	; 0xcfe <button_press_ISR()+0xee>
system_wake():
     c2a:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:116
  ADC0.CTRLA &= ~ADC_ENABLE_bm;
  sleep_cpu();
}

void system_wake(void) {
  digitalWrite(NRF_PS_EN, LOW);   // Power up NRF module
     c2c:	82 e0       	ldi	r24, 0x02	; 2
     c2e:	80 dc       	rcall	.-1792   	; 0x530 <digitalWrite>
     c30:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:117
  ADC0.CTRLA |= ADC_ENABLE_bm;    // Enable ADC for battery voltage check
     c34:	81 60       	ori	r24, 0x01	; 1
     c36:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
     c3a:	65 e0       	ldi	r22, 0x05	; 5
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:118
  delay(5);                       // Wait for NRF module to be ready
     c3c:	70 e0       	ldi	r23, 0x00	; 0
     c3e:	80 e0       	ldi	r24, 0x00	; 0
     c40:	90 e0       	ldi	r25, 0x00	; 0
     c42:	e3 db       	rcall	.-2106   	; 0x40a <delay>
     c44:	ed de       	rcall	.-550    	; 0xa20 <nrf_setup()>
_Z16button_press_ISRv():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:119
  nrf_setup();                    // Re-initialise NRF module
     c46:	80 91 f6 60 	lds	r24, 0x60F6	; 0x8060f6 <button_pressed>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:87
    return;
  }
  
  system_wake();

  if (button_pressed == 0) {
     c4a:	81 11       	cpse	r24, r1
     c4c:	58 c0       	rjmp	.+176    	; 0xcfe <button_press_ISR()+0xee>
     c4e:	81 e1       	ldi	r24, 0x11	; 17
     c50:	54 dc       	rcall	.-1880   	; 0x4fa <digitalRead>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:88
    if (!digitalRead(BTN_CANCEL)) {
     c52:	88 23       	and	r24, r24
     c54:	09 f4       	brne	.+2      	; 0xc58 <button_press_ISR()+0x48>
     c56:	50 c0       	rjmp	.+160    	; 0xcf8 <button_press_ISR()+0xe8>
     c58:	61 e0       	ldi	r22, 0x01	; 1
     c5a:	88 e0       	ldi	r24, 0x08	; 8
     c5c:	69 dc       	rcall	.-1838   	; 0x530 <digitalWrite>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:92
      button_pressed = CANCEL_VAL;
      return;
    }
    for (int col = 0; col < 4; col++) digitalWrite(col_output_pin[col], HIGH);
     c5e:	61 e0       	ldi	r22, 0x01	; 1
     c60:	89 e0       	ldi	r24, 0x09	; 9
     c62:	66 dc       	rcall	.-1844   	; 0x530 <digitalWrite>
     c64:	61 e0       	ldi	r22, 0x01	; 1
     c66:	8a e0       	ldi	r24, 0x0A	; 10
     c68:	63 dc       	rcall	.-1850   	; 0x530 <digitalWrite>
     c6a:	61 e0       	ldi	r22, 0x01	; 1
     c6c:	8b e0       	ldi	r24, 0x0B	; 11
     c6e:	60 dc       	rcall	.-1856   	; 0x530 <digitalWrite>
     c70:	9d e4       	ldi	r25, 0x4D	; 77
     c72:	e9 2e       	mov	r14, r25
     c74:	90 e6       	ldi	r25, 0x60	; 96
     c76:	f9 2e       	mov	r15, r25
     c78:	d0 e0       	ldi	r29, 0x00	; 0
     c7a:	c0 e0       	ldi	r28, 0x00	; 0
     c7c:	f7 01       	movw	r30, r14
     c7e:	00 81       	ld	r16, Z
     c80:	f2 e0       	ldi	r31, 0x02	; 2
     c82:	ef 0e       	add	r14, r31
     c84:	f1 1c       	adc	r15, r1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:93
    for (int col = 0; col < 4; col++) {
     c86:	60 e0       	ldi	r22, 0x00	; 0
     c88:	80 2f       	mov	r24, r16
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:95
      if (col > 0) digitalWrite(col_output_pin[col - 1], HIGH);
      digitalWrite(col_output_pin[col], LOW);
     c8a:	52 dc       	rcall	.-1884   	; 0x530 <digitalWrite>
     c8c:	61 e0       	ldi	r22, 0x01	; 1
     c8e:	70 e0       	ldi	r23, 0x00	; 0
     c90:	80 e0       	ldi	r24, 0x00	; 0
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	ba db       	rcall	.-2188   	; 0x40a <delay>
     c96:	85 e5       	ldi	r24, 0x55	; 85
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:96
      delay(1);  // Allow capacitor to discharge
     c98:	c8 2e       	mov	r12, r24
     c9a:	80 e6       	ldi	r24, 0x60	; 96
     c9c:	d8 2e       	mov	r13, r24
     c9e:	1c 2f       	mov	r17, r28
     ca0:	bc 2e       	mov	r11, r28
     ca2:	80 e1       	ldi	r24, 0x10	; 16
     ca4:	b8 0e       	add	r11, r24
     ca6:	f6 01       	movw	r30, r12
     ca8:	80 81       	ld	r24, Z
     caa:	f2 e0       	ldi	r31, 0x02	; 2
     cac:	cf 0e       	add	r12, r31
     cae:	d1 1c       	adc	r13, r1
     cb0:	24 dc       	rcall	.-1976   	; 0x4fa <digitalRead>
     cb2:	81 11       	cpse	r24, r1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:98
      for (int row = 0; row < 4; row++) {
        if (!digitalRead(row_input_pin[row])) {
     cb4:	04 c0       	rjmp	.+8      	; 0xcbe <button_press_ISR()+0xae>
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	81 0f       	add	r24, r17
     cba:	80 93 f6 60 	sts	0x60F6, r24	; 0x8060f6 <button_pressed>
     cbe:	1c 5f       	subi	r17, 0xFC	; 252
     cc0:	1b 11       	cpse	r17, r11
     cc2:	f1 cf       	rjmp	.-30     	; 0xca6 <button_press_ISR()+0x96>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:99
          button_pressed = (row * 4) + (col + 1);
     cc4:	21 96       	adiw	r28, 0x01	; 1
     cc6:	c4 30       	cpi	r28, 0x04	; 4
     cc8:	d1 05       	cpc	r29, r1
     cca:	91 f4       	brne	.+36     	; 0xcf0 <button_press_ISR()+0xe0>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:97
    for (int col = 0; col < 4; col++) digitalWrite(col_output_pin[col], HIGH);
    for (int col = 0; col < 4; col++) {
      if (col > 0) digitalWrite(col_output_pin[col - 1], HIGH);
      digitalWrite(col_output_pin[col], LOW);
      delay(1);  // Allow capacitor to discharge
      for (int row = 0; row < 4; row++) {
     ccc:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:93
    if (!digitalRead(BTN_CANCEL)) {
      button_pressed = CANCEL_VAL;
      return;
    }
    for (int col = 0; col < 4; col++) digitalWrite(col_output_pin[col], HIGH);
    for (int col = 0; col < 4; col++) {
     cce:	88 e0       	ldi	r24, 0x08	; 8
     cd0:	2f dc       	rcall	.-1954   	; 0x530 <digitalWrite>
     cd2:	60 e0       	ldi	r22, 0x00	; 0
     cd4:	89 e0       	ldi	r24, 0x09	; 9
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:103
        if (!digitalRead(row_input_pin[row])) {
          button_pressed = (row * 4) + (col + 1);
        }
      }
    }
    for (int col = 0; col < 3; col++) digitalWrite(col_output_pin[col], LOW);
     cd6:	2c dc       	rcall	.-1960   	; 0x530 <digitalWrite>
     cd8:	60 e0       	ldi	r22, 0x00	; 0
     cda:	8a e0       	ldi	r24, 0x0A	; 10
     cdc:	df 91       	pop	r29
     cde:	cf 91       	pop	r28
     ce0:	1f 91       	pop	r17
     ce2:	0f 91       	pop	r16
     ce4:	ff 90       	pop	r15
     ce6:	ef 90       	pop	r14
     ce8:	df 90       	pop	r13
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:105
  }
}
     cea:	cf 90       	pop	r12
     cec:	bf 90       	pop	r11
     cee:	20 cc       	rjmp	.-1984   	; 0x530 <digitalWrite>
     cf0:	61 e0       	ldi	r22, 0x01	; 1
     cf2:	80 2f       	mov	r24, r16
     cf4:	1d dc       	rcall	.-1990   	; 0x530 <digitalWrite>
     cf6:	c2 cf       	rjmp	.-124    	; 0xc7c <button_press_ISR()+0x6c>
     cf8:	81 e1       	ldi	r24, 0x11	; 17
     cfa:	80 93 f6 60 	sts	0x60F6, r24	; 0x8060f6 <button_pressed>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:103
        if (!digitalRead(row_input_pin[row])) {
          button_pressed = (row * 4) + (col + 1);
        }
      }
    }
    for (int col = 0; col < 3; col++) digitalWrite(col_output_pin[col], LOW);
     cfe:	df 91       	pop	r29
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:94
      button_pressed = CANCEL_VAL;
      return;
    }
    for (int col = 0; col < 4; col++) digitalWrite(col_output_pin[col], HIGH);
    for (int col = 0; col < 4; col++) {
      if (col > 0) digitalWrite(col_output_pin[col - 1], HIGH);
     d00:	cf 91       	pop	r28
     d02:	1f 91       	pop	r17
     d04:	0f 91       	pop	r16
     d06:	ff 90       	pop	r15
     d08:	ef 90       	pop	r14
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:89
  
  system_wake();

  if (button_pressed == 0) {
    if (!digitalRead(BTN_CANCEL)) {
      button_pressed = CANCEL_VAL;
     d0a:	df 90       	pop	r13
     d0c:	cf 90       	pop	r12
     d0e:	bf 90       	pop	r11
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:105
        }
      }
    }
    for (int col = 0; col < 3; col++) digitalWrite(col_output_pin[col], LOW);
  }
}
     d10:	08 95       	ret

00000d12 <get_batt_level()>:
_Z14get_batt_levelv():
     d12:	86 e0       	ldi	r24, 0x06	; 6
     d14:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <__TEXT_REGION_LENGTH__+0x7f0608>
     d18:	81 e0       	ldi	r24, 0x01	; 1
     d1a:	80 93 0a 06 	sts	0x060A, r24	; 0x80060a <__TEXT_REGION_LENGTH__+0x7f060a>
     d1e:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <__TEXT_REGION_LENGTH__+0x7f060d>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:136
    pin = digitalPinToAnalogInput(pin);
    if(pin == NOT_A_PIN) return -1;

  }
  /* Select channel */
  ADC0.MUXPOS = ((pin & 0x7F) << ADC_MUXPOS_gp);
     d22:	80 ff       	sbrs	r24, 0
     d24:	fc cf       	rjmp	.-8      	; 0xd1e <get_batt_level()+0xc>
     d26:	20 91 10 06 	lds	r18, 0x0610	; 0x800610 <__TEXT_REGION_LENGTH__+0x7f0610>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:140
  /* Reference should be already set up */

  /* Start conversion */
  ADC0.COMMAND = ADC_STCONV_bm;
     d2a:	30 91 11 06 	lds	r19, 0x0611	; 0x800611 <__TEXT_REGION_LENGTH__+0x7f0611>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:143

  /* Wait for result ready */
  while(!(ADC0.INTFLAGS & ADC_RESRDY_bm));
     d2e:	23 3a       	cpi	r18, 0xA3	; 163
     d30:	82 e0       	ldi	r24, 0x02	; 2
     d32:	38 07       	cpc	r19, r24
     d34:	c8 f0       	brcs	.+50     	; 0xd68 <get_batt_level()+0x56>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:149

  #if (defined(__AVR_DA__) && (!defined(NO_ADC_WORKAROUND)))
    // That may become defined when DA-series silicon is available with the fix
    ADC0.MUXPOS = 0x40;
  #endif
  return ADC0.RES;
     d36:	50 e0       	ldi	r21, 0x00	; 0
     d38:	40 e0       	ldi	r20, 0x00	; 0
map():
     d3a:	23 5a       	subi	r18, 0xA3	; 163
     d3c:	32 40       	sbci	r19, 0x02	; 2
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:132
    SerialDebug.print("V batt raw = ");
    SerialDebug.println(v_batt_raw);
  }

  // Check if battery is below min voltage (Tx will not work reliably below this voltage)
  if (v_batt_raw < (VBAT_EMPTY_mV / VBAT_DIV)) {
     d3e:	41 09       	sbc	r20, r1
     d40:	51 09       	sbc	r21, r1
     d42:	a7 e0       	ldi	r26, 0x07	; 7
     d44:	b0 e0       	ldi	r27, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:136
    return 8;
  }

  batt_level = (uint8_t)map(v_batt_raw, VBAT_EMPTY_mV / VBAT_DIV, VBAT_FULL_mV / VBAT_DIV, 0, 7);
     d46:	44 d4       	rcall	.+2184   	; 0x15d0 <__muluhisi3>
     d48:	24 e6       	ldi	r18, 0x64	; 100
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore\api/Common.cpp:5
#include "Common.h"

/* C++ prototypes */
long map(long x, long in_min, long in_max, long out_min, long out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
     d4a:	30 e0       	ldi	r19, 0x00	; 0
     d4c:	40 e0       	ldi	r20, 0x00	; 0
     d4e:	50 e0       	ldi	r21, 0x00	; 0
     d50:	23 d4       	rcall	.+2118   	; 0x1598 <__divmodsi4>
_Z14get_batt_levelv():
     d52:	28 30       	cpi	r18, 0x08	; 8
     d54:	28 f4       	brcc	.+10     	; 0xd60 <get_batt_level()+0x4e>
     d56:	20 93 00 60 	sts	0x6000, r18	; 0x806000 <__DATA_REGION_ORIGIN__>
     d5a:	80 91 00 60 	lds	r24, 0x6000	; 0x806000 <__DATA_REGION_ORIGIN__>
     d5e:	08 95       	ret
     d60:	87 e0       	ldi	r24, 0x07	; 7
     d62:	80 93 00 60 	sts	0x6000, r24	; 0x806000 <__DATA_REGION_ORIGIN__>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:137
  if (batt_level > 7) batt_level = 7;
     d66:	f9 cf       	rjmp	.-14     	; 0xd5a <get_batt_level()+0x48>
     d68:	88 e0       	ldi	r24, 0x08	; 8
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:136
  // Check if battery is below min voltage (Tx will not work reliably below this voltage)
  if (v_batt_raw < (VBAT_EMPTY_mV / VBAT_DIV)) {
    return 8;
  }

  batt_level = (uint8_t)map(v_batt_raw, VBAT_EMPTY_mV / VBAT_DIV, VBAT_FULL_mV / VBAT_DIV, 0, 7);
     d6a:	08 95       	ret

00000d6c <__vector_22>:
__vector_22():
     d6c:	ef 93       	push	r30
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:138
  if (batt_level > 7) batt_level = 7;
  return batt_level;
     d6e:	ff 93       	push	r31
     d70:	f8 98       	cbi	0x1f, 0	; 31
     d72:	eb ef       	ldi	r30, 0xFB	; 251
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:137
  if (v_batt_raw < (VBAT_EMPTY_mV / VBAT_DIV)) {
    return 8;
  }

  batt_level = (uint8_t)map(v_batt_raw, VBAT_EMPTY_mV / VBAT_DIV, VBAT_FULL_mV / VBAT_DIV, 0, 7);
  if (batt_level > 7) batt_level = 7;
     d74:	f0 e6       	ldi	r31, 0x60	; 96
     d76:	0b c0       	rjmp	.+22     	; 0xd8e <_do_dre()>

00000d78 <__vector_21>:
__vector_21():
     d78:	ef 93       	push	r30
     d7a:	ff 93       	push	r31
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:133
    SerialDebug.println(v_batt_raw);
  }

  // Check if battery is below min voltage (Tx will not work reliably below this voltage)
  if (v_batt_raw < (VBAT_EMPTY_mV / VBAT_DIV)) {
    return 8;
     d7c:	f8 98       	cbi	0x1f, 0	; 31
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:139
  }

  batt_level = (uint8_t)map(v_batt_raw, VBAT_EMPTY_mV / VBAT_DIV, VBAT_FULL_mV / VBAT_DIV, 0, 7);
  if (batt_level > 7) batt_level = 7;
  return batt_level;
}
     d7e:	eb ef       	ldi	r30, 0xFB	; 251
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART0.cpp:119
    ISR(USART0_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"       "\n\t"
                "push  r31"       "\n\t"
                "cbi   0x1F, 0"   "\n\t"
                :::);
     d80:	f0 e6       	ldi	r31, 0x60	; 96
     d82:	33 c0       	rjmp	.+102    	; 0xdea <_do_rxc()>

00000d84 <__vector_23>:
__vector_23():
     d84:	ef 93       	push	r30
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART0.cpp:126
#if PROGMEM_SIZE > 8192
                "jmp _do_dre"     "\n\t"
#else
                "rjmp _do_dre"    "\n\t"
#endif
                ::"z"(&Serial0));
     d86:	ff 93       	push	r31
     d88:	eb ef       	ldi	r30, 0xFB	; 251
     d8a:	f0 e6       	ldi	r31, 0x60	; 96
     d8c:	5e c0       	rjmp	.+188    	; 0xe4a <_do_txc()>

00000d8e <_do_dre()>:
_Z7_do_drev():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART0.cpp:96
      ISR(USART0_RXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t" //we start out 5-6 clocks behind the ball, then do 2 push + 2 ldi + 2-3 for jump = 11 or 13 clocks to _do_rxc (and dre is the same)
              "push      r31"     "\n\t"
              "cbi   0x1F, 0"     "\n\t"
              :::);
     d8e:	2f 93       	push	r18
     d90:	2f b7       	in	r18, 0x3f	; 63
     d92:	2f 93       	push	r18
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART0.cpp:103
#if PROGMEM_SIZE > 8192
              "jmp   _do_rxc"     "\n\t"
#else
              "rjmp   _do_rxc"    "\n\t"
#endif
              ::"z"(&Serial0));
     d94:	8f 93       	push	r24
     d96:	9f 93       	push	r25
     d98:	af 93       	push	r26
     d9a:	bf 93       	push	r27
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART0.cpp:59
#elif defined(USE_ASM_TXC) && USE_ASM_TXC == 2
    ISR(USART0_TXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t"
              "push      r31"     "\n\t"
              :::);
     d9c:	68 94       	set

00000d9e <_poll_dre>:
     d9e:	cf 93       	push	r28
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART0.cpp:66
#if PROGMEM_SIZE > 8192
              "jmp   _do_txc"     "\n\t"
#else
              "rjmp   _do_txc"    "\n\t"
#endif
              ::"z"(&Serial0));
     da0:	df 93       	push	r29
     da2:	20 e0       	ldi	r18, 0x00	; 0
     da4:	c0 85       	ldd	r28, Z+8	; 0x08
     da6:	d8 e0       	ldi	r29, 0x08	; 8
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:387
          "out        0x3f,     r18"      "\n\t"  // restore SREG
          "pop         r18"               "\n\t"  // pop old r18
          "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
          "pop         r30"               "\n\t"
          "reti"                          "\n"   // and RETI!
          ::);
     da8:	92 89       	ldd	r25, Z+18	; 0x12
     daa:	df 01       	movw	r26, r30
     dac:	a9 0f       	add	r26, r25
     dae:	b2 1f       	adc	r27, r18
     db0:	ad 5a       	subi	r26, 0xAD	; 173
     db2:	bf 4f       	sbci	r27, 0xFF	; 255
     db4:	8c 91       	ld	r24, X
     db6:	20 e4       	ldi	r18, 0x40	; 64
     db8:	2c 83       	std	Y+4, r18	; 0x04
     dba:	8a 83       	std	Y+2, r24	; 0x02
     dbc:	9f 5f       	subi	r25, 0xFF	; 255
     dbe:	9f 73       	andi	r25, 0x3F	; 63
     dc0:	8d 81       	ldd	r24, Y+5	; 0x05
     dc2:	21 89       	ldd	r18, Z+17	; 0x11
     dc4:	29 13       	cpse	r18, r25
     dc6:	02 c0       	rjmp	.+4      	; 0xdcc <_done_dre_irq>
     dc8:	8f 7d       	andi	r24, 0xDF	; 223
     dca:	8d 83       	std	Y+5, r24	; 0x05

00000dcc <_done_dre_irq>:
     dcc:	92 8b       	std	Z+18, r25	; 0x12
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	0e f0       	brts	.+2      	; 0xdd6 <_done_dre_irq+0xa>
     dd4:	63 ca       	rjmp	.-2874   	; 0x29c <_poll_dre_done>
     dd6:	bf 91       	pop	r27
     dd8:	af 91       	pop	r26
     dda:	9f 91       	pop	r25
     ddc:	8f 91       	pop	r24
     dde:	2f 91       	pop	r18
     de0:	2f bf       	out	0x3f, r18	; 63
     de2:	2f 91       	pop	r18
     de4:	ff 91       	pop	r31
     de6:	ef 91       	pop	r30
     de8:	18 95       	reti

00000dea <_do_rxc()>:
_Z7_do_rxcv():
     dea:	2f 93       	push	r18
     dec:	2f b7       	in	r18, 0x3f	; 63
     dee:	2f 93       	push	r18
     df0:	3f 93       	push	r19
     df2:	8f 93       	push	r24
     df4:	9f 93       	push	r25
     df6:	cf 93       	push	r28
     df8:	df 93       	push	r29
     dfa:	c0 85       	ldd	r28, Z+8	; 0x08
     dfc:	d8 e0       	ldi	r29, 0x08	; 8
     dfe:	2e 81       	ldd	r18, Y+6	; 0x06
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:252
            "pop        r30"              "\n\t" // pointer to serial instance
            "reti"                        "\n\t" // return
          "_buff_full_rxc:"               "\n\t" // _buff_full_rxc moved to after the reti, and then rjmps back, saving 2 clocks for the common case
            "ori        r19,      0x40"   "\n\t" // record that there was a ring buffer overflow. 1 clk
            "rjmp _end_rxc"               "\n\t" // and now jump back to end. That way we don't need to jump over this in the middle of the common case.
            ::); // total: 77 or 79 clocks, just barely squeaks by for cyclic RX of up to RX_BUFFER_SIZE characters.
     e00:	2f 7e       	andi	r18, 0xEF	; 239
     e02:	2e 83       	std	Y+6, r18	; 0x06
     e04:	89 81       	ldd	r24, Y+1	; 0x01
     e06:	98 81       	ld	r25, Y
     e08:	86 74       	andi	r24, 0x46	; 70
     e0a:	88 0f       	add	r24, r24
     e0c:	36 85       	ldd	r19, Z+14	; 0x0e
     e0e:	38 2b       	or	r19, r24
     e10:	82 fd       	sbrc	r24, 2
     e12:	0d c0       	rjmp	.+26     	; 0xe2e <_end_rxc>
     e14:	c7 85       	ldd	r28, Z+15	; 0x0f
     e16:	81 e0       	ldi	r24, 0x01	; 1
     e18:	8c 0f       	add	r24, r28
     e1a:	8f 73       	andi	r24, 0x3F	; 63
     e1c:	20 89       	ldd	r18, Z+16	; 0x10
     e1e:	28 17       	cp	r18, r24
     e20:	91 f0       	breq	.+36     	; 0xe46 <_buff_full_rxc>
     e22:	ce 0f       	add	r28, r30
     e24:	df 2f       	mov	r29, r31
     e26:	20 e0       	ldi	r18, 0x00	; 0
     e28:	d2 1f       	adc	r29, r18
     e2a:	9b 8b       	std	Y+19, r25	; 0x13
     e2c:	87 87       	std	Z+15, r24	; 0x0f

00000e2e <_end_rxc>:
     e2e:	36 87       	std	Z+14, r19	; 0x0e
     e30:	df 91       	pop	r29
     e32:	cf 91       	pop	r28
     e34:	9f 91       	pop	r25
     e36:	8f 91       	pop	r24
     e38:	3f 91       	pop	r19
     e3a:	2f 91       	pop	r18
     e3c:	2f bf       	out	0x3f, r18	; 63
     e3e:	2f 91       	pop	r18
     e40:	ff 91       	pop	r31
     e42:	ef 91       	pop	r30
     e44:	18 95       	reti

00000e46 <_buff_full_rxc>:
     e46:	30 64       	ori	r19, 0x40	; 64
     e48:	f2 cf       	rjmp	.-28     	; 0xe2e <_end_rxc>

00000e4a <_do_txc()>:
_Z7_do_txcv():
     e4a:	8f 93       	push	r24
     e4c:	8f b7       	in	r24, 0x3f	; 63
     e4e:	8f 93       	push	r24
     e50:	9f 93       	push	r25
     e52:	cf 93       	push	r28
     e54:	df 93       	push	r29
     e56:	c0 85       	ldd	r28, Z+8	; 0x08
     e58:	d8 e0       	ldi	r29, 0x08	; 8
     e5a:	9d 81       	ldd	r25, Y+5	; 0x05

00000e5c <_txc_flush_rx>:
     e5c:	88 81       	ld	r24, Y
     e5e:	8c 81       	ldd	r24, Y+4	; 0x04
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/UART.cpp:127
            "pop        r24"              "\n\t"  // pop r24 restore it
            "pop        r31"              "\n\t"  // and r31
            "pop        r30"              "\n\t"  // Pop the register the ISR did
            "reti"                        "\n"    // return from the interrupt.
            ::
          );
     e60:	87 fd       	sbrc	r24, 7
     e62:	fc cf       	rjmp	.-8      	; 0xe5c <_txc_flush_rx>
     e64:	9f 7b       	andi	r25, 0xBF	; 191
     e66:	90 68       	ori	r25, 0x80	; 128
     e68:	9d 83       	std	Y+5, r25	; 0x05
     e6a:	df 91       	pop	r29
     e6c:	cf 91       	pop	r28
     e6e:	9f 91       	pop	r25
     e70:	8f 91       	pop	r24
     e72:	8f bf       	out	0x3f, r24	; 63
     e74:	8f 91       	pop	r24
     e76:	ff 91       	pop	r31
     e78:	ef 91       	pop	r30
     e7a:	18 95       	reti

00000e7c <__vector_30>:
__vector_30():
     e7c:	ef 93       	push	r30
     e7e:	ff 93       	push	r31
     e80:	e7 ef       	ldi	r30, 0xF7	; 247
     e82:	f0 e6       	ldi	r31, 0x60	; 96
     e84:	8f 93       	push	r24
     e86:	8f b7       	in	r24, 0x3f	; 63
     e88:	8f 93       	push	r24
     e8a:	80 81       	ld	r24, Z
     e8c:	8f 5f       	subi	r24, 0xFF	; 255
     e8e:	80 83       	st	Z, r24
     e90:	81 81       	ldd	r24, Z+1	; 0x01
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:203
      }
      RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm; // clear flag
    }
  #else
    ISR(MILLIS_TIMER_VECTOR, ISR_NAKED) {
      __asm__ __volatile__(
     e92:	8f 4f       	sbci	r24, 0xFF	; 255
     e94:	81 83       	std	Z+1, r24	; 0x01
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:208
      "push       r30"          "\n\t" // First we make room for the pointer to timingStruct by pushing the Z registers
      "push       r31"          "\n\t" //
      ::);
    #if defined(MILLIS_USE_TCB)
      __asm__ __volatile__(
     e96:	82 81       	ldd	r24, Z+2	; 0x02
     e98:	8f 4f       	sbci	r24, 0xFF	; 255
     e9a:	82 83       	std	Z+2, r24	; 0x02
     e9c:	83 81       	ldd	r24, Z+3	; 0x03
     e9e:	8f 4f       	sbci	r24, 0xFF	; 255
     ea0:	83 83       	std	Z+3, r24	; 0x03
     ea2:	81 e0       	ldi	r24, 0x01	; 1
     ea4:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7f0b26>
     ea8:	8f 91       	pop	r24
     eaa:	8f bf       	out	0x3f, r24	; 63
     eac:	8f 91       	pop	r24
     eae:	ff 91       	pop	r31
     eb0:	ef 91       	pop	r30
     eb2:	18 95       	reti

00000eb4 <__vector_34>:
__vector_34():
     eb4:	0f 93       	push	r16
     eb6:	0a e0       	ldi	r16, 0x0A	; 10
     eb8:	06 c0       	rjmp	.+12     	; 0xec6 <isrBody>

00000eba <__vector_24>:
__vector_24():
     eba:	0f 93       	push	r16
     ebc:	06 e0       	ldi	r16, 0x06	; 6
     ebe:	03 c0       	rjmp	.+6      	; 0xec6 <isrBody>

00000ec0 <__vector_8>:
__vector_8():
     ec0:	0f 93       	push	r16
     ec2:	00 e0       	ldi	r16, 0x00	; 0
     ec4:	00 c0       	rjmp	.+0      	; 0xec6 <isrBody>

00000ec6 <isrBody>:
isrBody():
     ec6:	0f 92       	push	r0
     ec8:	0f b6       	in	r0, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:418
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTF
      ISR(PORTF_PORT_vect, ISR_NAKED){
      asm volatile(
     eca:	0f 92       	push	r0
     ecc:	0b b6       	in	r0, 0x3b	; 59
     ece:	0f 92       	push	r0
     ed0:	1f 92       	push	r1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:398
        "rjmp AttachedISR" "\n\t"
#endif
    #endif
    #ifdef PORTD
      ISR(PORTD_PORT_vect, ISR_NAKED){
      asm volatile(
     ed2:	11 24       	eor	r1, r1
     ed4:	ff 92       	push	r15
     ed6:	1f 93       	push	r17
     ed8:	2f 93       	push	r18
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:360
 * then it's just a matter of making sure we pop everything we pushed onto the stack in the reverse order, including r16 followed by the reti to exit the interrupt..
*/

  #if defined(CORE_ATTACH_ALL)
    ISR(PORTA_PORT_vect, ISR_NAKED) {
    asm volatile(
     eda:	3f 93       	push	r19
     edc:	4f 93       	push	r20
     ede:	5f 93       	push	r21
     ee0:	6f 93       	push	r22
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:148

  }

#if !defined(CORE_ATTACH_EARLYCLEAR)
  void __attribute__((naked)) __attribute__((used)) __attribute__((noreturn)) isrBody() {
    asm volatile (
     ee2:	7f 93       	push	r23
     ee4:	8f 93       	push	r24
     ee6:	9f 93       	push	r25
     ee8:	af 93       	push	r26
     eea:	bf 93       	push	r27
     eec:	cf 93       	push	r28
     eee:	df 93       	push	r29
     ef0:	ef 93       	push	r30
     ef2:	ff 93       	push	r31
     ef4:	a7 e0       	ldi	r26, 0x07	; 7
     ef6:	b0 e6       	ldi	r27, 0x60	; 96
     ef8:	a0 0f       	add	r26, r16
     efa:	b1 1d       	adc	r27, r1
     efc:	cd 91       	ld	r28, X+
     efe:	dc 91       	ld	r29, X
     f00:	00 0f       	add	r16, r16
     f02:	0d 5f       	subi	r16, 0xFD	; 253
     f04:	a0 2f       	mov	r26, r16
     f06:	b0 e0       	ldi	r27, 0x00	; 0
     f08:	fc 90       	ld	r15, X
     f0a:	10 97       	sbiw	r26, 0x00	; 0
     f0c:	61 f0       	breq	.+24     	; 0xf26 <AIntEnd>
     f0e:	1f 2d       	mov	r17, r15

00000f10 <AIntLoop>:
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/WInterrupts.c:174
      "push  r28"        "\n\t" // Not call used, but we use it.
      "push  r29"        "\n\t" // same thing.
      "push  r30"        "\n\t"
      "push  r31"        "\n\t"
      ::);
    asm volatile (  // This gets us the address of intFunc in Y pointer reg.
     f10:	16 95       	lsr	r17
     f12:	18 f0       	brcs	.+6      	; 0xf1a <AIntLoop+0xa>
     f14:	41 f0       	breq	.+16     	; 0xf26 <AIntEnd>
     f16:	22 96       	adiw	r28, 0x02	; 2
     f18:	fb cf       	rjmp	.-10     	; 0xf10 <AIntLoop>
     f1a:	e9 91       	ld	r30, Y+
     f1c:	f9 91       	ld	r31, Y+
     f1e:	30 97       	sbiw	r30, 0x00	; 0
     f20:	b9 f3       	breq	.-18     	; 0xf10 <AIntLoop>
     f22:	09 95       	icall
     f24:	f5 cf       	rjmp	.-22     	; 0xf10 <AIntLoop>

00000f26 <AIntEnd>:
     f26:	a0 2f       	mov	r26, r16
     f28:	b0 e0       	ldi	r27, 0x00	; 0
     f2a:	fc 92       	st	X, r15
     f2c:	ff 91       	pop	r31
     f2e:	ef 91       	pop	r30
     f30:	df 91       	pop	r29
     f32:	cf 91       	pop	r28
     f34:	bf 91       	pop	r27
     f36:	af 91       	pop	r26
     f38:	9f 91       	pop	r25
     f3a:	8f 91       	pop	r24
     f3c:	7f 91       	pop	r23
     f3e:	6f 91       	pop	r22
     f40:	5f 91       	pop	r21
     f42:	4f 91       	pop	r20
     f44:	3f 91       	pop	r19
     f46:	2f 91       	pop	r18
     f48:	1f 91       	pop	r17
     f4a:	ff 90       	pop	r15
     f4c:	1f 90       	pop	r1
     f4e:	0f 90       	pop	r0
     f50:	0b be       	out	0x3b, r0	; 59
     f52:	0f 90       	pop	r0
     f54:	0f be       	out	0x3f, r0	; 63
     f56:	0f 90       	pop	r0
     f58:	0f 91       	pop	r16
     f5a:	18 95       	reti

00000f5c <global constructors keyed to 65535_0_Target_Control_Remote_v1.2.ino.cpp.o.3442>:
_GLOBAL__I_65535_0_Target_Control_Remote_v1.2.ino.cpp.o.3442():
     f5c:	10 92 fd 60 	sts	0x60FD, r1	; 0x8060fd <Serial0+0x2>
     f60:	10 92 fe 60 	sts	0x60FE, r1	; 0x8060fe <Serial0+0x3>
     f64:	88 ee       	ldi	r24, 0xE8	; 232
     f66:	93 e0       	ldi	r25, 0x03	; 3
     f68:	a0 e0       	ldi	r26, 0x00	; 0
     f6a:	b0 e0       	ldi	r27, 0x00	; 0
     f6c:	80 93 ff 60 	sts	0x60FF, r24	; 0x8060ff <Serial0+0x4>
     f70:	90 93 00 61 	sts	0x6100, r25	; 0x806100 <Serial0+0x5>
     f74:	a0 93 01 61 	sts	0x6101, r26	; 0x806101 <Serial0+0x6>
     f78:	b0 93 02 61 	sts	0x6102, r27	; 0x806102 <Serial0+0x7>
     f7c:	89 e9       	ldi	r24, 0x99	; 153
     f7e:	90 e6       	ldi	r25, 0x60	; 96
     f80:	80 93 fb 60 	sts	0x60FB, r24	; 0x8060fb <Serial0>
     f84:	90 93 fc 60 	sts	0x60FC, r25	; 0x8060fc <Serial0+0x1>
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	98 e0       	ldi	r25, 0x08	; 8
     f8c:	80 93 03 61 	sts	0x6103, r24	; 0x806103 <Serial0+0x8>
     f90:	90 93 04 61 	sts	0x6104, r25	; 0x806104 <Serial0+0x9>
     f94:	86 e9       	ldi	r24, 0x96	; 150
     f96:	90 e0       	ldi	r25, 0x00	; 0
     f98:	80 93 05 61 	sts	0x6105, r24	; 0x806105 <Serial0+0xa>
     f9c:	90 93 06 61 	sts	0x6106, r25	; 0x806106 <Serial0+0xb>
     fa0:	85 e0       	ldi	r24, 0x05	; 5
     fa2:	80 93 07 61 	sts	0x6107, r24	; 0x806107 <Serial0+0xc>
     fa6:	10 92 08 61 	sts	0x6108, r1	; 0x806108 <Serial0+0xd>
     faa:	10 92 09 61 	sts	0x6109, r1	; 0x806109 <Serial0+0xe>
     fae:	40 e0       	ldi	r20, 0x00	; 0
     fb0:	5b e1       	ldi	r21, 0x1B	; 27
     fb2:	67 eb       	ldi	r22, 0xB7	; 183
     fb4:	70 e0       	ldi	r23, 0x00	; 0
     fb6:	80 e0       	ldi	r24, 0x00	; 0
     fb8:	8f 5f       	subi	r24, 0xFF	; 255
     fba:	86 30       	cpi	r24, 0x06	; 6
     fbc:	11 f4       	brne	.+4      	; 0xfc2 <global constructors keyed to 65535_0_Target_Control_Remote_v1.2.ino.cpp.o.3442+0x66>
     fbe:	87 e0       	ldi	r24, 0x07	; 7
     fc0:	0b c0       	rjmp	.+22     	; 0xfd8 <global constructors keyed to 65535_0_Target_Control_Remote_v1.2.ino.cpp.o.3442+0x7c>
     fc2:	76 95       	lsr	r23
     fc4:	67 95       	ror	r22
     fc6:	57 95       	ror	r21
     fc8:	47 95       	ror	r20
     fca:	41 30       	cpi	r20, 0x01	; 1
     fcc:	99 e0       	ldi	r25, 0x09	; 9
     fce:	59 07       	cpc	r21, r25
     fd0:	9d e3       	ldi	r25, 0x3D	; 61
     fd2:	69 07       	cpc	r22, r25
     fd4:	71 05       	cpc	r23, r1
     fd6:	80 f7       	brcc	.-32     	; 0xfb8 <global constructors keyed to 65535_0_Target_Control_Remote_v1.2.ino.cpp.o.3442+0x5c>
     fd8:	91 e0       	ldi	r25, 0x01	; 1
     fda:	89 27       	eor	r24, r25
     fdc:	44 e0       	ldi	r20, 0x04	; 4
     fde:	40 93 8f 61 	sts	0x618F, r20	; 0x80618f <DEFAULT_SPI_SETTINGS+0x1>
     fe2:	50 e1       	ldi	r21, 0x10	; 16
     fe4:	85 9f       	mul	r24, r21
     fe6:	90 01       	movw	r18, r0
     fe8:	11 24       	eor	r1, r1
     fea:	20 71       	andi	r18, 0x10	; 16
     fec:	86 70       	andi	r24, 0x06	; 6
     fee:	81 62       	ori	r24, 0x21	; 33
     ff0:	82 2b       	or	r24, r18
     ff2:	80 93 8e 61 	sts	0x618E, r24	; 0x80618e <DEFAULT_SPI_SETTINGS>
     ff6:	20 e4       	ldi	r18, 0x40	; 64
     ff8:	39 e0       	ldi	r19, 0x09	; 9
     ffa:	20 93 90 61 	sts	0x6190, r18	; 0x806190 <SPI>
     ffe:	30 93 91 61 	sts	0x6191, r19	; 0x806191 <SPI+0x1>
    1002:	40 93 93 61 	sts	0x6193, r20	; 0x806193 <SPI+0x3>
    1006:	86 e0       	ldi	r24, 0x06	; 6
    1008:	80 93 94 61 	sts	0x6194, r24	; 0x806194 <SPI+0x4>
    100c:	10 92 96 61 	sts	0x6196, r1	; 0x806196 <SPI+0x6>
    1010:	10 92 97 61 	sts	0x6197, r1	; 0x806197 <SPI+0x7>
    1014:	23 e0       	ldi	r18, 0x03	; 3
    1016:	30 e0       	ldi	r19, 0x00	; 0
    1018:	20 93 9d 61 	sts	0x619D, r18	; 0x80619d <radio+0x2>
    101c:	30 93 9e 61 	sts	0x619E, r19	; 0x80619e <radio+0x3>
    1020:	27 e0       	ldi	r18, 0x07	; 7
    1022:	30 e0       	ldi	r19, 0x00	; 0
    1024:	20 93 9f 61 	sts	0x619F, r18	; 0x80619f <radio+0x4>
    1028:	30 93 a0 61 	sts	0x61A0, r19	; 0x8061a0 <radio+0x5>
    102c:	40 e8       	ldi	r20, 0x80	; 128
    102e:	56 e9       	ldi	r21, 0x96	; 150
    1030:	68 e9       	ldi	r22, 0x98	; 152
    1032:	70 e0       	ldi	r23, 0x00	; 0
    1034:	40 93 a1 61 	sts	0x61A1, r20	; 0x8061a1 <radio+0x6>
    1038:	50 93 a2 61 	sts	0x61A2, r21	; 0x8061a2 <radio+0x7>
    103c:	60 93 a3 61 	sts	0x61A3, r22	; 0x8061a3 <radio+0x8>
    1040:	70 93 a4 61 	sts	0x61A4, r23	; 0x8061a4 <radio+0x9>
    1044:	80 e2       	ldi	r24, 0x20	; 32
    1046:	80 93 a6 61 	sts	0x61A6, r24	; 0x8061a6 <radio+0xb>
    104a:	10 92 ad 61 	sts	0x61AD, r1	; 0x8061ad <radio+0x12>
    104e:	10 92 ae 61 	sts	0x61AE, r1	; 0x8061ae <radio+0x13>
    1052:	85 e0       	ldi	r24, 0x05	; 5
    1054:	80 93 b0 61 	sts	0x61B0, r24	; 0x8061b0 <radio+0x15>
    1058:	90 93 b1 61 	sts	0x61B1, r25	; 0x8061b1 <radio+0x16>
    105c:	85 e0       	ldi	r24, 0x05	; 5
    105e:	90 e0       	ldi	r25, 0x00	; 0
    1060:	a0 e0       	ldi	r26, 0x00	; 0
    1062:	b0 e0       	ldi	r27, 0x00	; 0
    1064:	80 93 b7 61 	sts	0x61B7, r24	; 0x8061b7 <radio+0x1c>
    1068:	90 93 b8 61 	sts	0x61B8, r25	; 0x8061b8 <radio+0x1d>
    106c:	a0 93 b9 61 	sts	0x61B9, r26	; 0x8061b9 <radio+0x1e>
    1070:	b0 93 ba 61 	sts	0x61BA, r27	; 0x8061ba <radio+0x1f>
    1074:	80 e9       	ldi	r24, 0x90	; 144
    1076:	91 e6       	ldi	r25, 0x61	; 97
    1078:	80 93 9b 61 	sts	0x619B, r24	; 0x80619b <radio>
    107c:	90 93 9c 61 	sts	0x619C, r25	; 0x80619c <radio+0x1>
    1080:	10 92 a7 61 	sts	0x61A7, r1	; 0x8061a7 <radio+0xc>
    1084:	08 95       	ret

00001086 <main>:
main():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/main.cpp:48
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
    1086:	cf 93       	push	r28
    1088:	df 93       	push	r29
    108a:	cd b7       	in	r28, 0x3d	; 61
    108c:	de b7       	in	r29, 0x3e	; 62
    108e:	6e 97       	sbiw	r28, 0x1e	; 30
    1090:	cd bf       	out	0x3d, r28	; 61
    1092:	de bf       	out	0x3e, r29	; 62
init_clock():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1614
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0B << 2));
    #elif (F_CPU == 28000000)
      /* Overclocked - generally quite reliable at room temperature, but a dumb frequency (see PWM section) */
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0A << 2));
    #elif (F_CPU == 24000000)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x09 << 2));
    1094:	88 ed       	ldi	r24, 0xD8	; 216
    1096:	94 e2       	ldi	r25, 0x24	; 36
    1098:	84 bf       	out	0x34, r24	; 52
    109a:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <__TEXT_REGION_LENGTH__+0x7f0068>
init_TCA0():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1884
}

void __attribute__((weak)) init_TCA0() {
  /* TCA0_PINS from pins_arduino.h */
  /* Enable Split Mode to get more PWM pins, since analogWrite() only provides 8-bit PWM anyway*/
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    109e:	31 e0       	ldi	r19, 0x01	; 1
    10a0:	30 93 03 0a 	sts	0x0A03, r19	; 0x800a03 <__TEXT_REGION_LENGTH__+0x7f0a03>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1889

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    10a4:	9e ef       	ldi	r25, 0xFE	; 254
    10a6:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <__TEXT_REGION_LENGTH__+0x7f0a26>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1890
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    10aa:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x7f0a27>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1917
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    10ae:	8b e0       	ldi	r24, 0x0B	; 11
    10b0:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x7f0a00>
init_timers():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1865
  init_TCA0();
  #if (defined(TCA1))
    PORTMUX.TCAROUTEA = TCA0_PINS | TCA1_PINS;
    init_TCA1();
  #else
    PORTMUX.TCAROUTEA = TCA0_PINS;
    10b4:	23 e0       	ldi	r18, 0x03	; 3
    10b6:	20 93 e7 05 	sts	0x05E7, r18	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7f05e7>
init_TCBs():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1972
 * Set up routing (defined in pins_arduino.h)
 * Notice how there's no semicolon until after the preprocessor conditionals.
 * In other words, that's all one line.
 */

  PORTMUX.TCBROUTEA = 0
    10ba:	20 93 e8 05 	sts	0x05E8, r18	; 0x8005e8 <__TEXT_REGION_LENGTH__+0x7f05e8>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2023
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    10be:	47 e0       	ldi	r20, 0x07	; 7
    10c0:	40 93 01 0b 	sts	0x0B01, r20	; 0x800b01 <__TEXT_REGION_LENGTH__+0x7f0b01>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2026

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    10c4:	90 93 0c 0b 	sts	0x0B0C, r25	; 0x800b0c <__TEXT_REGION_LENGTH__+0x7f0b0c>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2029
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    10c8:	10 92 0d 0b 	sts	0x0B0D, r1	; 0x800b0d <__TEXT_REGION_LENGTH__+0x7f0b0d>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2032

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    10cc:	85 e0       	ldi	r24, 0x05	; 5
    10ce:	80 93 00 0b 	sts	0x0B00, r24	; 0x800b00 <__TEXT_REGION_LENGTH__+0x7f0b00>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2023
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    10d2:	40 93 11 0b 	sts	0x0B11, r20	; 0x800b11 <__TEXT_REGION_LENGTH__+0x7f0b11>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2026

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    10d6:	90 93 1c 0b 	sts	0x0B1C, r25	; 0x800b1c <__TEXT_REGION_LENGTH__+0x7f0b1c>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2029
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    10da:	10 92 1d 0b 	sts	0x0B1D, r1	; 0x800b1d <__TEXT_REGION_LENGTH__+0x7f0b1d>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2032

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    10de:	80 93 10 0b 	sts	0x0B10, r24	; 0x800b10 <__TEXT_REGION_LENGTH__+0x7f0b10>
init_TCD0():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2076
 * be set in the status register. We skip checking this here because, as we do many places the  *
 * initiialization functions assume that the chip starts from a reset condition.                */

void __attribute__((weak)) init_TCD0() {
  #if defined(USE_TIMERD0_PWM) || defined (MILLIS_USE_TIMERD0)
    TCD0.CMPACLR  = 0x0FFF;
    10e2:	4f ef       	ldi	r20, 0xFF	; 255
    10e4:	5f e0       	ldi	r21, 0x0F	; 15
    10e6:	40 93 aa 0b 	sts	0x0BAA, r20	; 0x800baa <__TEXT_REGION_LENGTH__+0x7f0baa>
    10ea:	50 93 ab 0b 	sts	0x0BAB, r21	; 0x800bab <__TEXT_REGION_LENGTH__+0x7f0bab>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2080
    // Match with CMPBCLR clears all outputs. For normal PWM this just needs to be higher than
    // it will count to - so set to maximum (other settings used for non-overlapping PWM and
    // other advanced functionality)
    TCD0.CTRLC    = 0x80;                   // WOD outputs PWM B, WOC outputs PWM A
    10ee:	90 e8       	ldi	r25, 0x80	; 128
    10f0:	90 93 82 0b 	sts	0x0B82, r25	; 0x800b82 <__TEXT_REGION_LENGTH__+0x7f0b82>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2082
    // That doesn't need to be that way, but I declare that that's all we support through analogWrite()
    TCD0.CTRLB    = TIMERD0_WGMODE_SETTING;
    10f4:	10 92 81 0b 	sts	0x0B81, r1	; 0x800b81 <__TEXT_REGION_LENGTH__+0x7f0b81>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2085
    // One ramp or dual slope are the only options that are viable to reproduce classic behavior without
    // considerable calculation overhead. We use one-ramp mode
    TCD0.CMPBCLR  = TIMERD0_TOP_SETTING;
    10f8:	4b ef       	ldi	r20, 0xFB	; 251
    10fa:	53 e0       	ldi	r21, 0x03	; 3
    10fc:	40 93 ae 0b 	sts	0x0BAE, r20	; 0x800bae <__TEXT_REGION_LENGTH__+0x7f0bae>
    1100:	50 93 af 0b 	sts	0x0BAF, r21	; 0x800baf <__TEXT_REGION_LENGTH__+0x7f0baf>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:2094
    #if defined(TIMERD0_SET_CLOCK)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (TIMERD0_SET_CLOCK));
    #endif


    TCD0.CTRLA    = TIMERD0_CLOCK_SETTING | TCD_ENABLE_bm;
    1104:	91 e7       	ldi	r25, 0x71	; 113
    1106:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
init_timers():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1871
  #endif
  init_TCBs();
  #if (defined(TCD0) && defined(USE_TIMERD0_PWM) && !defined(MILLIS_USE_TIMERD0))
    init_TCD0();
    #if defined(ERRATA_TCD_PORTMUX) && ERRATA_TCD_PORTMUX == 0 && defined(TCD0_PINS)
      PORTMUX.TCDROUTEA = TCD0_PINS;
    110a:	92 e0       	ldi	r25, 0x02	; 2
    110c:	90 93 e9 05 	sts	0x05E9, r25	; 0x8005e9 <__TEXT_REGION_LENGTH__+0x7f05e9>
init_ADC0():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1508
    #elif F_CPU >= 36000000
      ADC0.CTRLC = ADC_PRESC_DIV28_gc; // 1.286 @ 36 MHz
    #elif F_CPU >  28000000
      ADC0.CTRLC = ADC_PRESC_DIV24_gc; // 1.33 @ 32 MHz, 1.
    #elif F_CPU >= 24000000
      ADC0.CTRLC = ADC_PRESC_DIV20_gc; // 1.2 @ 24, 1.25 @ 25, 1.4 @ 28  MHz
    1110:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__TEXT_REGION_LENGTH__+0x7f0602>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1520
    #elif F_CPU >= 4000000
      ADC0.CTRLC = ADC_PRESC_DIV4_gc;  // 1 MHz
    #else  // 1 MHz / 2 = 500 kHz - the lowest setting
      ADC0.CTRLC = ADC_PRESC_DIV2_gc;
    #endif
    ADC0.SAMPCTRL = 14; // 16 ADC clock sampling time - should be about the same amount of *time* as originally?
    1114:	9e e0       	ldi	r25, 0x0E	; 14
    1116:	90 93 05 06 	sts	0x0605, r25	; 0x800605 <__TEXT_REGION_LENGTH__+0x7f0605>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1522
    // This is WAY conservative! We could drop it down...
    ADC0.CTRLD = ADC_INITDLY_DLY64_gc; // VREF can take 50uS to become ready, and we're running the ADC clock
    111a:	90 e6       	ldi	r25, 0x60	; 96
    111c:	90 93 03 06 	sts	0x0603, r25	; 0x800603 <__TEXT_REGION_LENGTH__+0x7f0603>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1525
    // at around 1 MHz, so we want 64 ADC clocks when we start up a new reference so we don't get bad readings at first
    /* Enable ADC */
    ADC0.CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;
    1120:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
analogReference():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:117


void analogReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.ADC0REF = (VREF.ADC0REF & ~(VREF_REFSEL_gm))|(mode);
    1124:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f00b0>
    1128:	88 7f       	andi	r24, 0xF8	; 248
    112a:	85 60       	ori	r24, 0x05	; 5
    112c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f00b0>
DACReference():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:124
}

void DACReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.DAC0REF = (VREF.DAC0REF & ~(VREF_REFSEL_gm))|(mode);
    1130:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f00b2>
    1134:	88 7f       	andi	r24, 0xF8	; 248
    1136:	85 60       	ori	r24, 0x05	; 5
    1138:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f00b2>
init_millis():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1442
        // RTC.CLKSEL=0; this is the power on value
      #endif
      RTC.INTCTRL         = 0x01; // enable overflow interrupt
      RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
    113c:	8f ed       	ldi	r24, 0xDF	; 223
    113e:	9e e2       	ldi	r25, 0x2E	; 46
    1140:	80 93 2c 0b 	sts	0x0B2C, r24	; 0x800b2c <__TEXT_REGION_LENGTH__+0x7f0b2c>
    1144:	90 93 2d 0b 	sts	0x0B2D, r25	; 0x800b2d <__TEXT_REGION_LENGTH__+0x7f0b2d>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1444
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
    1148:	30 93 25 0b 	sts	0x0B25, r19	; 0x800b25 <__TEXT_REGION_LENGTH__+0x7f0b25>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1446
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
    114c:	10 92 21 0b 	sts	0x0B21, r1	; 0x800b21 <__TEXT_REGION_LENGTH__+0x7f0b21>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:1448
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
    1150:	20 93 20 0b 	sts	0x0B20, r18	; 0x800b20 <__TEXT_REGION_LENGTH__+0x7f0b20>
main():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/main.cpp:52
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
    1154:	78 94       	sei
analogReference():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:117


void analogReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.ADC0REF = (VREF.ADC0REF & ~(VREF_REFSEL_gm))|(mode);
    1156:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f00b0>
    115a:	88 7f       	andi	r24, 0xF8	; 248
    115c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f00b0>
analogReadResolution():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_analog.c:331
    }
  }
  if (res == 12) {
    ADC0.CTRLA = (ADC0.CTRLA & (~ADC_RESSEL_gm)) | ADC_RESSEL_12BIT_gc;
  } else {
    ADC0.CTRLA = (ADC0.CTRLA & (~ADC_RESSEL_gm)) | ADC_RESSEL_10BIT_gc;
    1160:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
    1164:	83 7f       	andi	r24, 0xF3	; 243
    1166:	84 60       	ori	r24, 0x04	; 4
    1168:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
    116c:	3d e4       	ldi	r19, 0x4D	; 77
    116e:	c3 2e       	mov	r12, r19
    1170:	30 e6       	ldi	r19, 0x60	; 96
    1172:	d3 2e       	mov	r13, r19
    1174:	05 e5       	ldi	r16, 0x55	; 85
    1176:	10 e6       	ldi	r17, 0x60	; 96
    1178:	45 e5       	ldi	r20, 0x55	; 85
    117a:	e4 2e       	mov	r14, r20
    117c:	40 e6       	ldi	r20, 0x60	; 96
    117e:	f4 2e       	mov	r15, r20
pin_setup():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:222
}

// MCU pins initialisation
void pin_setup(void) {
  for (int i = 0; i < 4; i++) {
    pinMode(col_output_pin[i], OUTPUT);
    1180:	d6 01       	movw	r26, r12
    1182:	8d 91       	ld	r24, X+
    1184:	9d 91       	ld	r25, X+
    1186:	6d 01       	movw	r12, r26
    1188:	9c 01       	movw	r18, r24
    118a:	33 27       	eor	r19, r19
_pinMode():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    118c:	8c 31       	cpi	r24, 0x1C	; 28
    118e:	80 f4       	brcc	.+32     	; 0x11b0 <main+0x12a>
    1190:	f9 01       	movw	r30, r18
    1192:	ef 5c       	subi	r30, 0xCF	; 207
    1194:	ff 49       	sbci	r31, 0x9F	; 159
    1196:	40 81       	ld	r20, Z
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1198:	4f 3f       	cpi	r20, 0xFF	; 255
    119a:	51 f0       	breq	.+20     	; 0x11b0 <main+0x12a>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    119c:	23 5a       	subi	r18, 0xA3	; 163
    119e:	3f 49       	sbci	r19, 0x9F	; 159
    11a0:	d9 01       	movw	r26, r18
    11a2:	ec 91       	ld	r30, X
    11a4:	b0 e2       	ldi	r27, 0x20	; 32
    11a6:	eb 9f       	mul	r30, r27
    11a8:	f0 01       	movw	r30, r0
    11aa:	11 24       	eor	r1, r1
    11ac:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    11ae:	41 83       	std	Z+1, r20	; 0x01
pin_setup():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:223
    digitalWrite(col_output_pin[i], LOW);
    11b0:	60 e0       	ldi	r22, 0x00	; 0
    11b2:	be d9       	rcall	.-3204   	; 0x530 <digitalWrite>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:224
    pinMode(row_input_pin[i], INPUT);
    11b4:	f8 01       	movw	r30, r16
    11b6:	21 91       	ld	r18, Z+
    11b8:	31 91       	ld	r19, Z+
    11ba:	8f 01       	movw	r16, r30
    11bc:	c9 01       	movw	r24, r18
    11be:	99 27       	eor	r25, r25
_pinMode():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    11c0:	2c 31       	cpi	r18, 0x1C	; 28
    11c2:	20 f5       	brcc	.+72     	; 0x120c <main+0x186>
    11c4:	fc 01       	movw	r30, r24
    11c6:	ef 5c       	subi	r30, 0xCF	; 207
    11c8:	ff 49       	sbci	r31, 0x9F	; 159
    11ca:	20 81       	ld	r18, Z
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    11cc:	2f 3f       	cpi	r18, 0xFF	; 255
    11ce:	f1 f0       	breq	.+60     	; 0x120c <main+0x186>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    11d0:	fc 01       	movw	r30, r24
    11d2:	e3 5a       	subi	r30, 0xA3	; 163
    11d4:	ff 49       	sbci	r31, 0x9F	; 159
    11d6:	a0 81       	ld	r26, Z
    11d8:	f0 e2       	ldi	r31, 0x20	; 32
    11da:	af 9f       	mul	r26, r31
    11dc:	d0 01       	movw	r26, r0
    11de:	11 24       	eor	r1, r1
    11e0:	bc 5f       	subi	r27, 0xFC	; 252
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:89
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    11e2:	87 58       	subi	r24, 0x87	; 135
    11e4:	9f 49       	sbci	r25, 0x9F	; 159
    11e6:	fc 01       	movw	r30, r24
    11e8:	30 81       	ld	r19, Z
main():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:90
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    11ea:	f0 e0       	ldi	r31, 0x00	; 0
    11ec:	e0 e0       	ldi	r30, 0x00	; 0
_pinMode():
    11ee:	38 30       	cpi	r19, 0x08	; 8
    11f0:	28 f4       	brcc	.+10     	; 0x11fc <main+0x176>
    11f2:	cd 01       	movw	r24, r26
    11f4:	40 96       	adiw	r24, 0x10	; 16
    11f6:	fc 01       	movw	r30, r24
    11f8:	e3 0f       	add	r30, r19
    11fa:	f1 1d       	adc	r31, r1
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:91
    uint8_t status = SREG;              /* Save state */
    11fc:	9f b7       	in	r25, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:92
    cli();                              /* Interrupts off for PINnCTRL stuff */
    11fe:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:93
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    1200:	12 96       	adiw	r26, 0x02	; 2
    1202:	2c 93       	st	X, r18
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:97
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    1204:	80 81       	ld	r24, Z
    1206:	87 7f       	andi	r24, 0xF7	; 247
    1208:	80 83       	st	Z, r24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:99
    }
    SREG = status;                      /* Restore state */
    120a:	9f bf       	out	0x3f, r25	; 63
pin_setup():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:221
  analogReadResolution(10);
}

// MCU pins initialisation
void pin_setup(void) {
  for (int i = 0; i < 4; i++) {
    120c:	ec 14       	cp	r14, r12
    120e:	fd 04       	cpc	r15, r13
    1210:	09 f0       	breq	.+2      	; 0x1214 <main+0x18e>
    1212:	b6 cf       	rjmp	.-148    	; 0x1180 <main+0xfa>
_pinMode():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:91
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    uint8_t status = SREG;              /* Save state */
    1214:	9f b7       	in	r25, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:92
    cli();                              /* Interrupts off for PINnCTRL stuff */
    1216:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:93
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    1218:	10 e2       	ldi	r17, 0x20	; 32
    121a:	10 93 62 04 	sts	0x0462, r17	; 0x800462 <__TEXT_REGION_LENGTH__+0x7f0462>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:97
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    121e:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <__TEXT_REGION_LENGTH__+0x7f0475>
    1222:	87 7f       	andi	r24, 0xF7	; 247
    1224:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <__TEXT_REGION_LENGTH__+0x7f0475>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:99
    }
    SREG = status;                      /* Restore state */
    1228:	9f bf       	out	0x3f, r25	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:86
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    122a:	84 e0       	ldi	r24, 0x04	; 4
    122c:	80 93 01 04 	sts	0x0401, r24	; 0x800401 <__TEXT_REGION_LENGTH__+0x7f0401>
pin_setup():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:228
    digitalWrite(col_output_pin[i], LOW);
    pinMode(row_input_pin[i], INPUT);
  }
  pinMode(BTN_CANCEL, INPUT);
  pinMode(NRF_PS_EN, OUTPUT);
  digitalWrite(NRF_PS_EN, HIGH);
    1230:	61 e0       	ldi	r22, 0x01	; 1
    1232:	82 e0       	ldi	r24, 0x02	; 2
    1234:	7d d9       	rcall	.-3334   	; 0x530 <digitalWrite>
_pinMode():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:86
    1236:	88 e0       	ldi	r24, 0x08	; 8
    1238:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <__TEXT_REGION_LENGTH__+0x7f04a1>
pin_setup():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:230
  pinMode(LED_RED, OUTPUT);
  digitalWrite(LED_RED, LOW);
    123c:	60 e0       	ldi	r22, 0x00	; 0
    123e:	87 e1       	ldi	r24, 0x17	; 23
    1240:	77 d9       	rcall	.-3346   	; 0x530 <digitalWrite>
_pinMode():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:86
    1242:	80 e1       	ldi	r24, 0x10	; 16
    1244:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <__TEXT_REGION_LENGTH__+0x7f04a1>
pin_setup():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:232
  pinMode(LED_GREEN, OUTPUT);
  digitalWrite(LED_GREEN, LOW);
    1248:	60 e0       	ldi	r22, 0x00	; 0
    124a:	88 e1       	ldi	r24, 0x18	; 24
    124c:	71 d9       	rcall	.-3358   	; 0x530 <digitalWrite>
_pinMode():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring_digital.c:86
    124e:	10 93 a1 04 	sts	0x04A1, r17	; 0x8004a1 <__TEXT_REGION_LENGTH__+0x7f04a1>
pin_setup():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:234
  pinMode(LED_BLUE, OUTPUT);
  digitalWrite(LED_BLUE, HIGH);
    1252:	61 e0       	ldi	r22, 0x01	; 1
    1254:	89 e1       	ldi	r24, 0x19	; 25
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:235
  delay(1000);
    1256:	6c d9       	rcall	.-3368   	; 0x530 <digitalWrite>
    1258:	68 ee       	ldi	r22, 0xE8	; 232
    125a:	73 e0       	ldi	r23, 0x03	; 3
    125c:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:236
  digitalWrite(NRF_PS_EN, LOW);
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	d4 d8       	rcall	.-3672   	; 0x40a <delay>
    1262:	60 e0       	ldi	r22, 0x00	; 0
    1264:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:12

void setup() {
  adc_setup();
  pin_setup();
  if (debug) serial_for_debug_setup();
  nrf_setup();
    1266:	64 d9       	rcall	.-3384   	; 0x530 <digitalWrite>
setup():
    1268:	db db       	rcall	.-2122   	; 0xa20 <nrf_setup()>
attachInterrupt():
    126a:	8d e0       	ldi	r24, 0x0D	; 13
    126c:	0e 94 93 00 	call	0x126	; 0x126 <attachInterrupt.part.0.constprop.21>
    1270:	8e e0       	ldi	r24, 0x0E	; 14
    1272:	0e 94 93 00 	call	0x126	; 0x126 <attachInterrupt.part.0.constprop.21>
    1276:	8f e0       	ldi	r24, 0x0F	; 15
    1278:	0e 94 93 00 	call	0x126	; 0x126 <attachInterrupt.part.0.constprop.21>
    127c:	80 e1       	ldi	r24, 0x10	; 16
    127e:	0e 94 93 00 	call	0x126	; 0x126 <attachInterrupt.part.0.constprop.21>
    1282:	81 e1       	ldi	r24, 0x11	; 17
    1284:	0e 94 93 00 	call	0x126	; 0x126 <attachInterrupt.part.0.constprop.21>
setup():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:14
  isr_setup();
  digitalWrite(LED_RED, HIGH);
    1288:	61 e0       	ldi	r22, 0x01	; 1
    128a:	87 e1       	ldi	r24, 0x17	; 23
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:15
  delay(1000);
    128c:	51 d9       	rcall	.-3422   	; 0x530 <digitalWrite>
    128e:	68 ee       	ldi	r22, 0xE8	; 232
    1290:	73 e0       	ldi	r23, 0x03	; 3
    1292:	80 e0       	ldi	r24, 0x00	; 0
    1294:	90 e0       	ldi	r25, 0x00	; 0
    1296:	b9 d8       	rcall	.-3726   	; 0x40a <delay>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:16
  digitalWrite(LED_GREEN, HIGH);
    1298:	61 e0       	ldi	r22, 0x01	; 1
    129a:	88 e1       	ldi	r24, 0x18	; 24
    129c:	49 d9       	rcall	.-3438   	; 0x530 <digitalWrite>
    129e:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x7f0050>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:17
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    12a2:	89 7f       	andi	r24, 0xF9	; 249
    12a4:	84 60       	ori	r24, 0x04	; 4
    12a6:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7f0050>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:18
  sleep_enable();
    12aa:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x7f0050>
    12ae:	81 60       	ori	r24, 0x01	; 1
    12b0:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7f0050>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:19
  system_sleep();
    12b4:	a3 dc       	rcall	.-1722   	; 0xbfc <system_sleep()>
loop():
    12b6:	08 e0       	ldi	r16, 0x08	; 8
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:29
//********************************************************************//

void loop() {
  if (button_pressed > 0) {
    digitalWrite(LED_RED, LOW);
    uint8_t payload[8] = { 0 };
    12b8:	7e 01       	movw	r14, r28
    12ba:	f1 e1       	ldi	r31, 0x11	; 17
    12bc:	ef 0e       	add	r14, r31
    12be:	f1 1c       	adc	r15, r1
pairing_mode():
    12c0:	90 ef       	ldi	r25, 0xF0	; 240
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:148
  if (batt_level > 7) return;   // Not enough battery voltage to attempt pairing
  
  pairing = true;
  
  uint8_t pair_packet[8];
  pair_packet[0] = PAIR_BYTE;
    12c2:	99 2e       	mov	r9, r25
    12c4:	27 e0       	ldi	r18, 0x07	; 7
    12c6:	a2 2e       	mov	r10, r18
    12c8:	20 e6       	ldi	r18, 0x60	; 96
    12ca:	b2 2e       	mov	r11, r18
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:176
      radio.setPayloadSize(8);
      radio.stopListening();
      radio.openWritingPipe(tx_pipe_uid);
      delay(200); // Wait for base station to switch to UID pipe

      uint8_t payload[8] = { 0 };
    12cc:	9e 01       	movw	r18, r28
    12ce:	2f 5f       	subi	r18, 0xFF	; 255
    12d0:	3f 4f       	sbci	r19, 0xFF	; 255
    12d2:	69 01       	movw	r12, r18
loop():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:27
//********************************************************************//
//--------------------------------Loop--------------------------------//
//********************************************************************//

void loop() {
  if (button_pressed > 0) {
    12d4:	80 91 f6 60 	lds	r24, 0x60F6	; 0x8060f6 <button_pressed>
    12d8:	88 23       	and	r24, r24
    12da:	09 f4       	brne	.+2      	; 0x12de <main+0x258>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:28
    digitalWrite(LED_RED, LOW);
    12dc:	39 c1       	rjmp	.+626    	; 0x1550 <main+0x4ca>
    12de:	60 e0       	ldi	r22, 0x00	; 0
    12e0:	87 e1       	ldi	r24, 0x17	; 23
    12e2:	26 d9       	rcall	.-3508   	; 0x530 <digitalWrite>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:29
    uint8_t payload[8] = { 0 };
    12e4:	d7 01       	movw	r26, r14
    12e6:	e0 2f       	mov	r30, r16
    12e8:	1d 92       	st	X+, r1
    12ea:	ea 95       	dec	r30
    12ec:	e9 f7       	brne	.-6      	; 0x12e8 <main+0x262>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:30
    payload[0] = button_pressed;
    12ee:	80 91 f6 60 	lds	r24, 0x60F6	; 0x8060f6 <button_pressed>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:31
    payload[1] = get_batt_level();
    12f2:	89 8b       	std	Y+17, r24	; 0x11
    12f4:	0e dd       	rcall	.-1508   	; 0xd12 <get_batt_level()>
    12f6:	8a 8b       	std	Y+18, r24	; 0x12
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:32
    payload[2] = ++ tx_packet_num; // Tx increments this number on every transmit so that consecutive packets are not identical, as these seem to be acknowledged and discarded by the Rx
    12f8:	90 91 f5 60 	lds	r25, 0x60F5	; 0x8060f5 <tx_packet_num>
    12fc:	9f 5f       	subi	r25, 0xFF	; 255
    12fe:	90 93 f5 60 	sts	0x60F5, r25	; 0x8060f5 <tx_packet_num>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:33
    if (payload[1] < 8) { // Battery ok
    1302:	9b 8b       	std	Y+19, r25	; 0x13
    1304:	88 30       	cpi	r24, 0x08	; 8
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1284
    return 1;
}

bool RF24::write(const void* buf, uint8_t len)
{
    return write(buf, len, 0);
    1306:	08 f0       	brcs	.+2      	; 0x130a <main+0x284>
    1308:	9a c0       	rjmp	.+308    	; 0x143e <main+0x3b8>
write():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:35
      bool tx_status = radio.write(&payload, sizeof(payload));
      if (tx_status) {
    130a:	c7 01       	movw	r24, r14
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:41
        if (debug) {
          SerialDebug.print("Transmission successful, ");  // payload was delivered
          SerialDebug.print("sent: ");
          SerialDebug.println(button_pressed);  // print payload sent
        }
        digitalWrite(LED_RED, HIGH);
    130c:	d2 da       	rcall	.-2652   	; 0x8b2 <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]>
loop():
    130e:	88 23       	and	r24, r24
    1310:	31 f0       	breq	.+12     	; 0x131e <main+0x298>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:42
        digitalWrite(LED_GREEN, LOW);
    1312:	61 e0       	ldi	r22, 0x01	; 1
    1314:	87 e1       	ldi	r24, 0x17	; 23
    1316:	0c d9       	rcall	.-3560   	; 0x530 <digitalWrite>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:44
      } else if (debug) SerialDebug.println("Transmission failed or timed out");  // payload was not delivered
      delay(200);
    1318:	60 e0       	ldi	r22, 0x00	; 0
    131a:	88 e1       	ldi	r24, 0x18	; 24
    131c:	09 d9       	rcall	.-3566   	; 0x530 <digitalWrite>
    131e:	68 ec       	ldi	r22, 0xC8	; 200
    1320:	70 e0       	ldi	r23, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:45
      digitalWrite(LED_RED, HIGH);
    1322:	80 e0       	ldi	r24, 0x00	; 0
    1324:	90 e0       	ldi	r25, 0x00	; 0
    1326:	71 d8       	rcall	.-3870   	; 0x40a <delay>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:46
      digitalWrite(LED_GREEN, HIGH);
    1328:	61 e0       	ldi	r22, 0x01	; 1
    132a:	87 e1       	ldi	r24, 0x17	; 23
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:53
      for (int i = 0; i < 50; i++) {
        digitalWrite(LED_RED, (digitalRead(LED_RED) ^ 1));
        delay(100);
      }
      delay(5000);
       digitalWrite(LED_RED, HIGH);
    132c:	01 d9       	rcall	.-3582   	; 0x530 <digitalWrite>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:56
    }
    
    button_pressed = 0;
    132e:	61 e0       	ldi	r22, 0x01	; 1
    1330:	88 e1       	ldi	r24, 0x18	; 24
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:59

    // Check for Cancel and Custom held down for 1s for pairing mode
    if ((!digitalRead(BTN_CANCEL)) && (!digitalRead(row_input_pin[3]))) {
    1332:	fe d8       	rcall	.-3588   	; 0x530 <digitalWrite>
    1334:	10 92 f6 60 	sts	0x60F6, r1	; 0x8060f6 <button_pressed>
    1338:	81 e1       	ldi	r24, 0x11	; 17
    133a:	df d8       	rcall	.-3650   	; 0x4fa <digitalRead>
    133c:	81 11       	cpse	r24, r1
    133e:	08 c1       	rjmp	.+528    	; 0x1550 <main+0x4ca>
    1340:	80 e1       	ldi	r24, 0x10	; 16
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:60
      delay(1000);
    1342:	db d8       	rcall	.-3658   	; 0x4fa <digitalRead>
    1344:	81 11       	cpse	r24, r1
    1346:	04 c1       	rjmp	.+520    	; 0x1550 <main+0x4ca>
    1348:	68 ee       	ldi	r22, 0xE8	; 232
    134a:	73 e0       	ldi	r23, 0x03	; 3
    134c:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:61
      if ((!digitalRead(BTN_CANCEL)) && (!digitalRead(row_input_pin[3]))) pairing_mode();
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	5c d8       	rcall	.-3912   	; 0x40a <delay>
    1352:	81 e1       	ldi	r24, 0x11	; 17
    1354:	d2 d8       	rcall	.-3676   	; 0x4fa <digitalRead>
    1356:	81 11       	cpse	r24, r1
    1358:	a7 c0       	rjmp	.+334    	; 0x14a8 <main+0x422>
    135a:	80 e1       	ldi	r24, 0x10	; 16
    135c:	ce d8       	rcall	.-3684   	; 0x4fa <digitalRead>
    135e:	81 11       	cpse	r24, r1
    1360:	a3 c0       	rjmp	.+326    	; 0x14a8 <main+0x422>
pairing_mode():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:142
  if (batt_level > 7) batt_level = 7;
  return batt_level;
}

void pairing_mode(void) {
  uint8_t batt_level = get_batt_level();
    1362:	d7 dc       	rcall	.-1618   	; 0xd12 <get_batt_level()>
    1364:	88 30       	cpi	r24, 0x08	; 8
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:143
  if (batt_level > 7) return;   // Not enough battery voltage to attempt pairing
    1366:	08 f0       	brcs	.+2      	; 0x136a <main+0x2e4>
    1368:	9f c0       	rjmp	.+318    	; 0x14a8 <main+0x422>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:145
  
  pairing = true;
    136a:	91 e0       	ldi	r25, 0x01	; 1
    136c:	90 93 f0 60 	sts	0x60F0, r25	; 0x8060f0 <pairing>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:148
  
  uint8_t pair_packet[8];
  pair_packet[0] = PAIR_BYTE;
    1370:	99 86       	std	Y+9, r9	; 0x09
    1372:	e1 e0       	ldi	r30, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:149
  for (int i = 0; i < 6; i++) pair_packet[i + 1] = tx_pipe_uid[i];
    1374:	f0 e6       	ldi	r31, 0x60	; 96
    1376:	de 01       	movw	r26, r28
    1378:	1a 96       	adiw	r26, 0x0a	; 10
    137a:	91 91       	ld	r25, Z+
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:150
  pair_packet[7] = batt_level;
    137c:	9d 93       	st	X+, r25
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:151
  uint8_t rx_pair_address[6] = { TCS_PAIR_ID };
    137e:	ae 16       	cp	r10, r30
    1380:	bf 06       	cpc	r11, r31
    1382:	d9 f7       	brne	.-10     	; 0x137a <main+0x2f4>
    1384:	88 8b       	std	Y+16, r24	; 0x10
    1386:	86 e0       	ldi	r24, 0x06	; 6
    1388:	ea ea       	ldi	r30, 0xAA	; 170
    138a:	f0 e6       	ldi	r31, 0x60	; 96
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:153

  radio.startListening();
    138c:	de 01       	movw	r26, r28
    138e:	59 96       	adiw	r26, 0x19	; 25
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:154
  radio.setPayloadSize(8);
    1390:	01 90       	ld	r0, Z+
    1392:	0d 92       	st	X+, r0
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:155
  radio.setPALevel(RF24_PA_LOW);
    1394:	8a 95       	dec	r24
    1396:	e1 f7       	brne	.-8      	; 0x1390 <main+0x30a>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:156
  radio.stopListening();
    1398:	19 db       	rcall	.-2510   	; 0x9cc <RF24::startListening() [clone .constprop.25]>
    139a:	88 e0       	ldi	r24, 0x08	; 8
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:157
  radio.openWritingPipe(rx_pair_address);
    139c:	0b da       	rcall	.-3050   	; 0x7b4 <RF24::setPayloadSize(unsigned char) [clone .constprop.29]>
    139e:	81 e0       	ldi	r24, 0x01	; 1
    13a0:	34 da       	rcall	.-2968   	; 0x80a <RF24::setPALevel(unsigned char, bool) [clone .constprop.41]>
    13a2:	f2 da       	rcall	.-2588   	; 0x988 <RF24::stopListening() [clone .constprop.30]>
    13a4:	ce 01       	movw	r24, r28
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:161

  uint8_t pair_attempts = 0;
  while (pair_attempts < MAX_PAIR_ATTEMPTS) {
    digitalWrite(LED_BLUE, LOW);
    13a6:	49 96       	adiw	r24, 0x19	; 25
    13a8:	58 da       	rcall	.-2896   	; 0x85a <RF24::openWritingPipe(unsigned char const*) [clone .constprop.31]>
    13aa:	14 e1       	ldi	r17, 0x14	; 20
    13ac:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1284
    13ae:	89 e1       	ldi	r24, 0x19	; 25
    13b0:	bf d8       	rcall	.-3714   	; 0x530 <digitalWrite>
write():
    13b2:	ce 01       	movw	r24, r28
    13b4:	09 96       	adiw	r24, 0x09	; 9
    13b6:	7d da       	rcall	.-2822   	; 0x8b2 <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:164

    bool rx_ack = radio.write(&pair_packet, sizeof(pair_packet));
    delay(10);
    13b8:	78 2e       	mov	r7, r24
pairing_mode():
    13ba:	6a e0       	ldi	r22, 0x0A	; 10
    13bc:	70 e0       	ldi	r23, 0x00	; 0
    13be:	80 e0       	ldi	r24, 0x00	; 0
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	23 d8       	rcall	.-4026   	; 0x40a <delay>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:166

    if (rx_ack) {
    13c4:	77 20       	and	r7, r7
    13c6:	09 f4       	brne	.+2      	; 0x13ca <main+0x344>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:167
      digitalWrite(LED_BLUE, HIGH);
    13c8:	a0 c0       	rjmp	.+320    	; 0x150a <main+0x484>
    13ca:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:168
      digitalWrite(LED_GREEN, LOW);
    13cc:	89 e1       	ldi	r24, 0x19	; 25
    13ce:	b0 d8       	rcall	.-3744   	; 0x530 <digitalWrite>
    13d0:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:407
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
    13d2:	88 e1       	ldi	r24, 0x18	; 24
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:408
    cli();
    13d4:	ad d8       	rcall	.-3750   	; 0x530 <digitalWrite>
millis():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:459
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
    13d6:	2f b7       	in	r18, 0x3f	; 63
    13d8:	f8 94       	cli
    13da:	80 91 f7 60 	lds	r24, 0x60F7	; 0x8060f7 <timingStruct>
    13de:	90 91 f8 60 	lds	r25, 0x60F8	; 0x8060f8 <timingStruct+0x1>
    13e2:	a0 91 f9 60 	lds	r26, 0x60F9	; 0x8060f9 <timingStruct+0x2>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:169
      pair_led_timeout_time = millis() + 10000;   //10s LED on time after successful pairing
    13e6:	b0 91 fa 60 	lds	r27, 0x60FA	; 0x8060fa <timingStruct+0x3>
    13ea:	2f bf       	out	0x3f, r18	; 63
pairing_mode():
    13ec:	80 5f       	subi	r24, 0xF0	; 240
    13ee:	98 4d       	sbci	r25, 0xD8	; 216
    13f0:	af 4f       	sbci	r26, 0xFF	; 255
    13f2:	bf 4f       	sbci	r27, 0xFF	; 255
    13f4:	80 93 f1 60 	sts	0x60F1, r24	; 0x8060f1 <pair_led_timeout_time>
    13f8:	90 93 f2 60 	sts	0x60F2, r25	; 0x8060f2 <pair_led_timeout_time+0x1>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:170
      radio.startListening();
    13fc:	a0 93 f3 60 	sts	0x60F3, r26	; 0x8060f3 <pair_led_timeout_time+0x2>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:171
      radio.setPayloadSize(8);
    1400:	b0 93 f4 60 	sts	0x60F4, r27	; 0x8060f4 <pair_led_timeout_time+0x3>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:172
      radio.stopListening();
    1404:	e3 da       	rcall	.-2618   	; 0x9cc <RF24::startListening() [clone .constprop.25]>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:173
      radio.openWritingPipe(tx_pipe_uid);
    1406:	88 e0       	ldi	r24, 0x08	; 8
    1408:	d5 d9       	rcall	.-3158   	; 0x7b4 <RF24::setPayloadSize(unsigned char) [clone .constprop.29]>
    140a:	be da       	rcall	.-2692   	; 0x988 <RF24::stopListening() [clone .constprop.30]>
    140c:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:174
      delay(200); // Wait for base station to switch to UID pipe
    140e:	90 e6       	ldi	r25, 0x60	; 96
    1410:	24 da       	rcall	.-3000   	; 0x85a <RF24::openWritingPipe(unsigned char const*) [clone .constprop.31]>
    1412:	68 ec       	ldi	r22, 0xC8	; 200
    1414:	70 e0       	ldi	r23, 0x00	; 0
    1416:	80 e0       	ldi	r24, 0x00	; 0
    1418:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:176

      uint8_t payload[8] = { 0 };
    141a:	0e 94 05 02 	call	0x40a	; 0x40a <delay>
    141e:	d6 01       	movw	r26, r12
    1420:	e0 2f       	mov	r30, r16
    1422:	1d 92       	st	X+, r1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:177
      payload[1] = get_batt_level();
    1424:	ea 95       	dec	r30
    1426:	e9 f7       	brne	.-6      	; 0x1422 <main+0x39c>
    1428:	74 dc       	rcall	.-1816   	; 0xd12 <get_batt_level()>
    142a:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\peake\Google Drive\Documents\Arduino\libraries\RF24/RF24.cpp:1284
    142c:	14 e1       	ldi	r17, 0x14	; 20
write():
    142e:	c6 01       	movw	r24, r12
    1430:	40 da       	rcall	.-2944   	; 0x8b2 <RF24::write(void const*, unsigned char, bool) [clone .constprop.34]>
pairing_mode():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:180
      uint8_t ack_attempts = 0;
      while (ack_attempts < 20) {
        if (radio.write(&payload, sizeof(payload))) {
    1432:	88 23       	and	r24, r24
    1434:	09 f1       	breq	.+66     	; 0x1478 <main+0x3f2>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:181
          digitalWrite(LED_BLUE, HIGH);
    1436:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:203
    pair_attempts ++;
  }
  digitalWrite(LED_BLUE, HIGH);
  digitalWrite(LED_RED, LOW);
  delay(2000);
  digitalWrite(LED_RED, HIGH);
    1438:	89 e1       	ldi	r24, 0x19	; 25
    143a:	7a d8       	rcall	.-3852   	; 0x530 <digitalWrite>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:33
    digitalWrite(LED_RED, LOW);
    uint8_t payload[8] = { 0 };
    payload[0] = button_pressed;
    payload[1] = get_batt_level();
    payload[2] = ++ tx_packet_num; // Tx increments this number on every transmit so that consecutive packets are not identical, as these seem to be acknowledged and discarded by the Rx
    if (payload[1] < 8) { // Battery ok
    143c:	25 c0       	rjmp	.+74     	; 0x1488 <main+0x402>
loop():
    143e:	82 e3       	ldi	r24, 0x32	; 50
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:49
      delay(200);
      digitalWrite(LED_RED, HIGH);
      digitalWrite(LED_GREEN, HIGH);
    } else {  // Low battery!
      for (int i = 0; i < 50; i++) {
        digitalWrite(LED_RED, (digitalRead(LED_RED) ^ 1));
    1440:	68 2e       	mov	r6, r24
    1442:	71 2c       	mov	r7, r1
    1444:	11 e0       	ldi	r17, 0x01	; 1
    1446:	87 e1       	ldi	r24, 0x17	; 23
    1448:	58 d8       	rcall	.-3920   	; 0x4fa <digitalRead>
    144a:	68 2f       	mov	r22, r24
    144c:	61 27       	eor	r22, r17
    144e:	87 e1       	ldi	r24, 0x17	; 23
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:50
        delay(100);
    1450:	6f d8       	rcall	.-3874   	; 0x530 <digitalWrite>
    1452:	64 e6       	ldi	r22, 0x64	; 100
    1454:	70 e0       	ldi	r23, 0x00	; 0
    1456:	80 e0       	ldi	r24, 0x00	; 0
    1458:	90 e0       	ldi	r25, 0x00	; 0
    145a:	0e 94 05 02 	call	0x40a	; 0x40a <delay>
    145e:	f1 e0       	ldi	r31, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:48
      } else if (debug) SerialDebug.println("Transmission failed or timed out");  // payload was not delivered
      delay(200);
      digitalWrite(LED_RED, HIGH);
      digitalWrite(LED_GREEN, HIGH);
    } else {  // Low battery!
      for (int i = 0; i < 50; i++) {
    1460:	6f 1a       	sub	r6, r31
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:52
        digitalWrite(LED_RED, (digitalRead(LED_RED) ^ 1));
        delay(100);
      }
      delay(5000);
    1462:	71 08       	sbc	r7, r1
    1464:	81 f7       	brne	.-32     	; 0x1446 <main+0x3c0>
    1466:	68 e8       	ldi	r22, 0x88	; 136
    1468:	73 e1       	ldi	r23, 0x13	; 19
    146a:	80 e0       	ldi	r24, 0x00	; 0
    146c:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:53
       digitalWrite(LED_RED, HIGH);
    146e:	0e 94 05 02 	call	0x40a	; 0x40a <delay>
    1472:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:188
          radio.setPALevel(RF24_PA_HIGH);
          pairing = false;
          return true;
        }
        ack_attempts ++;
        delay(10);
    1474:	87 e1       	ldi	r24, 0x17	; 23
    1476:	5d cf       	rjmp	.-326    	; 0x1332 <main+0x2ac>
pairing_mode():
    1478:	6a e0       	ldi	r22, 0x0A	; 10
    147a:	70 e0       	ldi	r23, 0x00	; 0
    147c:	80 e0       	ldi	r24, 0x00	; 0
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	0e 94 05 02 	call	0x40a	; 0x40a <delay>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:204
  }
  digitalWrite(LED_BLUE, HIGH);
  digitalWrite(LED_RED, LOW);
  delay(2000);
  digitalWrite(LED_RED, HIGH);
  for (int col = 0; col < 4; col++) digitalWrite(col_output_pin[col], LOW);
    1484:	11 50       	subi	r17, 0x01	; 1
    1486:	99 f6       	brne	.-90     	; 0x142e <main+0x3a8>
    1488:	60 e0       	ldi	r22, 0x00	; 0
    148a:	88 e0       	ldi	r24, 0x08	; 8
    148c:	51 d8       	rcall	.-3934   	; 0x530 <digitalWrite>
    148e:	60 e0       	ldi	r22, 0x00	; 0
    1490:	89 e0       	ldi	r24, 0x09	; 9
    1492:	4e d8       	rcall	.-3940   	; 0x530 <digitalWrite>
    1494:	60 e0       	ldi	r22, 0x00	; 0
    1496:	8a e0       	ldi	r24, 0x0A	; 10
    1498:	4b d8       	rcall	.-3946   	; 0x530 <digitalWrite>
    149a:	60 e0       	ldi	r22, 0x00	; 0
    149c:	8b e0       	ldi	r24, 0x0B	; 11
    149e:	48 d8       	rcall	.-3952   	; 0x530 <digitalWrite>
    14a0:	82 e0       	ldi	r24, 0x02	; 2
    14a2:	b3 d9       	rcall	.-3226   	; 0x80a <RF24::setPALevel(unsigned char, bool) [clone .constprop.41]>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:205
  radio.setPALevel(RF24_PA_HIGH);
    14a4:	10 92 f0 60 	sts	0x60F0, r1	; 0x8060f0 <pairing>
loop():
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:206
  pairing = false;
    14a8:	80 91 f1 60 	lds	r24, 0x60F1	; 0x8060f1 <pair_led_timeout_time>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:62

    // Check for Cancel and Custom held down for 1s for pairing mode
    if ((!digitalRead(BTN_CANCEL)) && (!digitalRead(row_input_pin[3]))) {
      delay(1000);
      if ((!digitalRead(BTN_CANCEL)) && (!digitalRead(row_input_pin[3]))) pairing_mode();
      while (pair_led_timeout_time > 0) {
    14ac:	90 91 f2 60 	lds	r25, 0x60F2	; 0x8060f2 <pair_led_timeout_time+0x1>
    14b0:	a0 91 f3 60 	lds	r26, 0x60F3	; 0x8060f3 <pair_led_timeout_time+0x2>
    14b4:	b0 91 f4 60 	lds	r27, 0x60F4	; 0x8060f4 <pair_led_timeout_time+0x3>
    14b8:	89 2b       	or	r24, r25
    14ba:	8a 2b       	or	r24, r26
    14bc:	8b 2b       	or	r24, r27
    14be:	09 f4       	brne	.+2      	; 0x14c2 <main+0x43c>
    14c0:	47 c0       	rjmp	.+142    	; 0x1550 <main+0x4ca>
millis():
    14c2:	2f b7       	in	r18, 0x3f	; 63
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:407
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
    14c4:	f8 94       	cli
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:408
    cli();
    14c6:	80 91 f7 60 	lds	r24, 0x60F7	; 0x8060f7 <timingStruct>
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:459
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
    14ca:	90 91 f8 60 	lds	r25, 0x60F8	; 0x8060f8 <timingStruct+0x1>
    14ce:	a0 91 f9 60 	lds	r26, 0x60F9	; 0x8060f9 <timingStruct+0x2>
    14d2:	b0 91 fa 60 	lds	r27, 0x60FA	; 0x8060fa <timingStruct+0x3>
    14d6:	2f bf       	out	0x3f, r18	; 63
loop():
C:\Users\peake\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.2\cores\dxcore/wiring.c:460
      SREG = oldSREG;
    14d8:	40 91 f1 60 	lds	r20, 0x60F1	; 0x8060f1 <pair_led_timeout_time>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:63
        if (millis() >= pair_led_timeout_time) {
    14dc:	50 91 f2 60 	lds	r21, 0x60F2	; 0x8060f2 <pair_led_timeout_time+0x1>
    14e0:	60 91 f3 60 	lds	r22, 0x60F3	; 0x8060f3 <pair_led_timeout_time+0x2>
    14e4:	70 91 f4 60 	lds	r23, 0x60F4	; 0x8060f4 <pair_led_timeout_time+0x3>
    14e8:	84 17       	cp	r24, r20
    14ea:	95 07       	cpc	r25, r21
    14ec:	a6 07       	cpc	r26, r22
    14ee:	b7 07       	cpc	r27, r23
    14f0:	d8 f2       	brcs	.-74     	; 0x14a8 <main+0x422>
    14f2:	10 92 f1 60 	sts	0x60F1, r1	; 0x8060f1 <pair_led_timeout_time>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:64
          pair_led_timeout_time = 0;
    14f6:	10 92 f2 60 	sts	0x60F2, r1	; 0x8060f2 <pair_led_timeout_time+0x1>
    14fa:	10 92 f3 60 	sts	0x60F3, r1	; 0x8060f3 <pair_led_timeout_time+0x2>
    14fe:	10 92 f4 60 	sts	0x60F4, r1	; 0x8060f4 <pair_led_timeout_time+0x3>
    1502:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:65
          digitalWrite(LED_GREEN, HIGH);
    1504:	88 e1       	ldi	r24, 0x18	; 24
    1506:	14 d8       	rcall	.-4056   	; 0x530 <digitalWrite>
    1508:	cf cf       	rjmp	.-98     	; 0x14a8 <main+0x422>
pairing_mode():
    150a:	64 ef       	ldi	r22, 0xF4	; 244
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:195
      for (int col = 0; col < 4; col++) digitalWrite(col_output_pin[col], LOW);
      radio.setPALevel(RF24_PA_HIGH);
      pairing = false;
      return false;
    }
    delay(500);
    150c:	71 e0       	ldi	r23, 0x01	; 1
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	0e 94 05 02 	call	0x40a	; 0x40a <delay>
    1516:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:196
    digitalWrite(LED_BLUE, HIGH);
    1518:	89 e1       	ldi	r24, 0x19	; 25
    151a:	0a d8       	rcall	.-4076   	; 0x530 <digitalWrite>
    151c:	64 ef       	ldi	r22, 0xF4	; 244
    151e:	71 e0       	ldi	r23, 0x01	; 1
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:197
    delay(500);
    1520:	80 e0       	ldi	r24, 0x00	; 0
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	0e 94 05 02 	call	0x40a	; 0x40a <delay>
    1528:	11 50       	subi	r17, 0x01	; 1
    152a:	09 f0       	breq	.+2      	; 0x152e <main+0x4a8>
    152c:	3f cf       	rjmp	.-386    	; 0x13ac <main+0x326>
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:160
  radio.setPALevel(RF24_PA_LOW);
  radio.stopListening();
  radio.openWritingPipe(rx_pair_address);

  uint8_t pair_attempts = 0;
  while (pair_attempts < MAX_PAIR_ATTEMPTS) {
    152e:	61 e0       	ldi	r22, 0x01	; 1
    1530:	89 e1       	ldi	r24, 0x19	; 25
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:200
    delay(500);
    digitalWrite(LED_BLUE, HIGH);
    delay(500);
    pair_attempts ++;
  }
  digitalWrite(LED_BLUE, HIGH);
    1532:	0e 94 98 02 	call	0x530	; 0x530 <digitalWrite>
    1536:	60 e0       	ldi	r22, 0x00	; 0
    1538:	87 e1       	ldi	r24, 0x17	; 23
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:201
  digitalWrite(LED_RED, LOW);
    153a:	0e 94 98 02 	call	0x530	; 0x530 <digitalWrite>
    153e:	60 ed       	ldi	r22, 0xD0	; 208
    1540:	77 e0       	ldi	r23, 0x07	; 7
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:202
  delay(2000);
    1542:	80 e0       	ldi	r24, 0x00	; 0
    1544:	90 e0       	ldi	r25, 0x00	; 0
    1546:	0e 94 05 02 	call	0x40a	; 0x40a <delay>
    154a:	61 e0       	ldi	r22, 0x01	; 1
    154c:	87 e1       	ldi	r24, 0x17	; 23
C:\Users\peake\Google Drive\Documents\Arduino\Target_Control_Remote_v1.2/Target_Control_Remote_v1.2.ino:203
  digitalWrite(LED_RED, HIGH);
    154e:	75 cf       	rjmp	.-278    	; 0x143a <main+0x3b4>
loop():
    1550:	55 db       	rcall	.-2390   	; 0xbfc <system_sleep()>
    1552:	c0 ce       	rjmp	.-640    	; 0x12d4 <main+0x24e>

00001554 <__udivmodsi4>:
__udivmodsi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    1554:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    1556:	1a 2e       	mov	r1, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    1558:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    155a:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    155c:	fd 01       	movw	r30, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    155e:	0d c0       	rjmp	.+26     	; 0x157a <__udivmodsi4_ep>

00001560 <__udivmodsi4_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    1560:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    1562:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    1564:	ee 1f       	adc	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    1566:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    1568:	a2 17       	cp	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    156a:	b3 07       	cpc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    156c:	e4 07       	cpc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    156e:	f5 07       	cpc	r31, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    1570:	20 f0       	brcs	.+8      	; 0x157a <__udivmodsi4_ep>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    1572:	a2 1b       	sub	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    1574:	b3 0b       	sbc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    1576:	e4 0b       	sbc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    1578:	f5 0b       	sbc	r31, r21

0000157a <__udivmodsi4_ep>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    157a:	66 1f       	adc	r22, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    157c:	77 1f       	adc	r23, r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    157e:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    1580:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    1582:	1a 94       	dec	r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    1584:	69 f7       	brne	.-38     	; 0x1560 <__udivmodsi4_loop>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    1586:	60 95       	com	r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    1588:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    158a:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    158c:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    158e:	9b 01       	movw	r18, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    1590:	ac 01       	movw	r20, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    1592:	bd 01       	movw	r22, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    1594:	cf 01       	movw	r24, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    1596:	08 95       	ret

00001598 <__divmodsi4>:
__divmodsi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
    1598:	05 2e       	mov	r0, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
    159a:	97 fb       	bst	r25, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
    159c:	16 f4       	brtc	.+4      	; 0x15a2 <__divmodsi4+0xa>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
    159e:	00 94       	com	r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
    15a0:	0f d0       	rcall	.+30     	; 0x15c0 <__negsi2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
    15a2:	57 fd       	sbrc	r21, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
    15a4:	05 d0       	rcall	.+10     	; 0x15b0 <__divmodsi4_neg2>
    15a6:	d6 df       	rcall	.-84     	; 0x1554 <__udivmodsi4>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
    15a8:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
    15aa:	02 d0       	rcall	.+4      	; 0x15b0 <__divmodsi4_neg2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
    15ac:	46 f4       	brtc	.+16     	; 0x15be <__divmodsi4_exit>
    15ae:	08 c0       	rjmp	.+16     	; 0x15c0 <__negsi2>

000015b0 <__divmodsi4_neg2>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
    15b0:	50 95       	com	r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
    15b2:	40 95       	com	r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
    15b4:	30 95       	com	r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
    15b6:	21 95       	neg	r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
    15b8:	3f 4f       	sbci	r19, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
    15ba:	4f 4f       	sbci	r20, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
    15bc:	5f 4f       	sbci	r21, 0xFF	; 255

000015be <__divmodsi4_exit>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
    15be:	08 95       	ret

000015c0 <__negsi2>:
__negsi2():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
    15c0:	90 95       	com	r25
    15c2:	80 95       	com	r24
    15c4:	70 95       	com	r23
    15c6:	61 95       	neg	r22
    15c8:	7f 4f       	sbci	r23, 0xFF	; 255
    15ca:	8f 4f       	sbci	r24, 0xFF	; 255
    15cc:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
    15ce:	08 95       	ret

000015d0 <__muluhisi3>:
__muluhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    15d0:	0f d0       	rcall	.+30     	; 0x15f0 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    15d2:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    15d4:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    15d6:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    15d8:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    15da:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    15dc:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    15de:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    15e0:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    15e2:	08 95       	ret

000015e4 <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    15e4:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    15e6:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    15e8:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    15ea:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    15ec:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    15ee:	09 94       	ijmp

000015f0 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    15f0:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    15f2:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    15f4:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    15f6:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    15f8:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    15fa:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    15fc:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    15fe:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    1600:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    1602:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    1604:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    1606:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    1608:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    160a:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    160c:	08 95       	ret

0000160e <_exit>:
exit():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    160e:	f8 94       	cli

00001610 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    1610:	ff cf       	rjmp	.-2      	; 0x1610 <__stop_program>
